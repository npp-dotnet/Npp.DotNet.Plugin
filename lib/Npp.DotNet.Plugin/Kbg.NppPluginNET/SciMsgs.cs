/*
 * SPDX-FileCopyrightText: 2024 Robert Di Pardo <dipardo.r@gmail.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

using System;

namespace Npp.DotNet.Plugin
{
    /// <summary>Definitions for Scintilla 5.5.2</summary>
    /// <remarks>Autogenerated 2024-08-22</remarks>
    [Flags]
    public enum SciMsg : uint
    {
        INVALID_POSITION = 0xFFFFFFFF,
        SCI_START = 2000,
        SCI_OPTIONAL_START = 3000,
        SCI_LEXER_START = 4000,
        /// <summary>
        /// SCI_ADDTEXT(position length, const char *text)<br/>
        /// This inserts the first length characters from the string text at the current position. This will
        /// include any 0's in the string that you might have expected to stop the insert operation. The current position is
        /// set at the end of the inserted text, but it is not scrolled into view.
        /// </summary>
        SCI_ADDTEXT = 2001,
        /// <summary>
        /// SCI_ADDSTYLEDTEXT(position length, cell *c)<br/>
        /// This behaves just like SCI_ADDTEXT, but inserts styled text.
        /// </summary>
        SCI_ADDSTYLEDTEXT = 2002,
        /// <summary>
        /// SCI_INSERTTEXT(position pos, const char *text)<br/>
        /// This inserts the zero terminated text string at position pos or at the current position if pos is -1. If
        /// the current position is after the insertion point then it is moved along with its surrounding text but no scrolling
        /// is performed.
        /// </summary>
        SCI_INSERTTEXT = 2003,
        /// <summary>
        /// SCI_CHANGEINSERTION(position length, const char *text)<br/>
        /// This may only be called from a SC_MOD_INSERTCHECK notification handler and will change the text being inserted to that
        /// provided.
        /// </summary>
        SCI_CHANGEINSERTION = 2672,
        SCI_CLEARALL = 2004,
        /// <summary>
        /// SCI_DELETERANGE(position start, position lengthDelete)<br/>
        /// Deletes a range of text in the document.
        /// </summary>
        SCI_DELETERANGE = 2645,
        SCI_CLEARDOCUMENTSTYLE = 2005,
        /// <summary>
        /// SCI_GETLENGTH -&gt; position<br/>
        /// Both these messages return the length of the document in bytes.
        /// </summary>
        SCI_GETLENGTH = 2006,
        /// <summary>
        /// SCI_GETCHARAT(position pos) -&gt; int<br/>
        /// This returns the character at pos in the document or 0 if pos is negative or past the end of the document.
        /// </summary>
        SCI_GETCHARAT = 2007,
        /// <summary>
        /// SCI_GETCURRENTPOS -&gt; position<br/>
        /// This returns the current position.
        /// </summary>
        SCI_GETCURRENTPOS = 2008,
        /// <summary>
        /// SCI_GETANCHOR -&gt; position<br/>
        /// This returns the current anchor position.
        /// </summary>
        SCI_GETANCHOR = 2009,
        /// <summary>
        /// SCI_GETSTYLEAT(position pos) -&gt; int<br/>
        /// </summary>
        SCI_GETSTYLEAT = 2010,
        /// <summary>
        /// SCI_GETSTYLEINDEXAT(position pos) -&gt; int<br/>
        /// This returns the style at pos in the document, or 0 if pos is negative or past the end of the document.
        /// SCI_GETSTYLEAT may return a negative number for styles over 127 whereas SCI_GETSTYLEINDEXAT will only return
        /// positive numbers. SCI_GETSTYLEINDEXAT should be preferred as it handles styles more consistently and may avoid
        /// problems with lexers that define more than 128 styles.
        /// </summary>
        SCI_GETSTYLEINDEXAT = 2038,
        SCI_REDO = 2011,
        /// <summary>
        /// SCI_SETUNDOCOLLECTION(bool collectUndo)<br/>
        /// </summary>
        SCI_SETUNDOCOLLECTION = 2012,
        SCI_SELECTALL = 2013,
        SCI_SETSAVEPOINT = 2014,
        /// <summary>
        /// SCI_GETSTYLEDTEXT(&lt;unused&gt;, Sci_TextRange *tr) -&gt; position<br/>
        /// </summary>
        SCI_GETSTYLEDTEXT = 2015,
        /// <summary>
        /// SCI_GETSTYLEDTEXTFULL(&lt;unused&gt;, Sci_TextRangeFull *tr) -&gt; position<br/>
        /// This collects styled text into a buffer using two bytes for each cell, with the character at the lower address of
        /// each pair and the style byte at the upper address. Characters between the positions cpMin and cpMax are
        /// copied to lpstrText (see struct Sci_TextRange and struct Sci_TextRangeFull in Scintilla.h ). Two 0
        /// bytes are added to the end of the text, so the buffer that lpstrText points at must be at least
        /// 2*(cpMax-cpMin)+2 bytes long. No check is made for sensible values of cpMin or cpMax. Positions outside
        /// the document return character codes and style bytes of 0.
        /// </summary>
        SCI_GETSTYLEDTEXTFULL = 2778,
        /// <summary>
        /// SCI_CANREDO -&gt; bool<br/>
        /// SCI_REDO undoes the effect of the last SCI_UNDO operation.
        /// </summary>
        SCI_CANREDO = 2016,
        /// <summary>
        /// SCI_MARKERLINEFROMHANDLE(int markerHandle) -&gt; line<br/>
        /// The markerHandle argument is an identifier for a marker returned by SCI_MARKERADD. This function searches
        /// the document for the marker with this handle and returns the line number that contains it or -1 if it is not found.
        /// </summary>
        SCI_MARKERLINEFROMHANDLE = 2017,
        /// <summary>
        /// SCI_MARKERDELETEHANDLE(int markerHandle)<br/>
        /// The markerHandle argument is an identifier for a marker returned by SCI_MARKERADD. This function searches
        /// the document for the marker with this handle and deletes the marker if it is found.
        /// </summary>
        SCI_MARKERDELETEHANDLE = 2018,
        /// <summary>
        /// SCI_MARKERHANDLEFROMLINE(line line, int which) -&gt; int<br/>
        /// </summary>
        SCI_MARKERHANDLEFROMLINE = 2732,
        /// <summary>
        /// SCI_MARKERNUMBERFROMLINE(line line, int which) -&gt; int<br/>
        /// These messages returns the Nth marker handle or marker number in a given line. Handles are returned by
        /// SCI_MARKERADD. If which is greater or equal to the number of markers on a line, this returns -1;
        /// </summary>
        SCI_MARKERNUMBERFROMLINE = 2733,
        /// <summary>
        /// SCI_GETUNDOCOLLECTION -&gt; bool<br/>
        /// You can control whether Scintilla collects undo information with SCI_SETUNDOCOLLECTION. Pass in true (1) to
        /// collect information and false (0) to stop collecting. If you stop collection, you should also use
        /// SCI_EMPTYUNDOBUFFER to avoid the undo buffer being unsynchronized with the data in the buffer.
        /// </summary>
        SCI_GETUNDOCOLLECTION = 2019,
        SCWS_INVISIBLE = 0,
        SCWS_VISIBLEALWAYS = 1,
        SCWS_VISIBLEAFTERINDENT = 2,
        SCWS_VISIBLEONLYININDENT = 3,
        /// <summary>
        /// SCI_GETVIEWWS -&gt; int<br/>
        /// White space can be made visible which may be useful for languages in which white space is significant, such as
        /// Python. Space characters appear as small centred dots and tab characters as light arrows pointing to the right.
        /// There are also ways to control the display of end of line characters. The two messages set and get the white
        /// space display mode. The viewWS argument can be one of:
        /// </summary>
        SCI_GETVIEWWS = 2020,
        /// <summary>
        /// SCI_SETVIEWWS(int viewWS)<br/>
        /// </summary>
        SCI_SETVIEWWS = 2021,
        SCTD_LONGARROW = 0,
        SCTD_STRIKEOUT = 1,
        /// <summary>
        /// SCI_GETTABDRAWMODE -&gt; int<br/>
        /// These two messages get and set how tab characters are drawn when white space is visible. The tabDrawMode
        /// argument can be one of:
        /// </summary>
        SCI_GETTABDRAWMODE = 2698,
        /// <summary>
        /// SCI_SETTABDRAWMODE(int tabDrawMode)<br/>
        /// </summary>
        SCI_SETTABDRAWMODE = 2699,
        /// <summary>
        /// SCI_POSITIONFROMPOINT(int x, int y) -&gt; position<br/>
        /// </summary>
        SCI_POSITIONFROMPOINT = 2022,
        /// <summary>
        /// SCI_POSITIONFROMPOINTCLOSE(int x, int y) -&gt; position<br/>
        /// SCI_POSITIONFROMPOINT finds the closest character position to a point and SCI_POSITIONFROMPOINTCLOSE is
        /// similar but returns -1 if the point is outside the window or not close to any characters.
        /// </summary>
        SCI_POSITIONFROMPOINTCLOSE = 2023,
        /// <summary>
        /// SCI_GOTOLINE(line line)<br/>
        /// This removes any selection and sets the caret at the start of line number line and scrolls the view (if needed)
        /// to make it visible. The anchor position is set the same as the current position. If line is outside the lines
        /// in the document (first line is 0), the line set is the first or last.
        /// </summary>
        SCI_GOTOLINE = 2024,
        /// <summary>
        /// SCI_GOTOPOS(position caret)<br/>
        /// This removes any selection, sets the caret at caret and scrolls the view to make the caret visible, if
        /// necessary. It is equivalent to SCI_SETSEL(caret, caret). The anchor position is set the same as the current
        /// position.
        /// </summary>
        SCI_GOTOPOS = 2025,
        /// <summary>
        /// SCI_SETANCHOR(position anchor)<br/>
        /// This sets the anchor position and creates a selection between the anchor position and the current position. The
        /// caret is not scrolled into view.
        /// </summary>
        SCI_SETANCHOR = 2026,
        /// <summary>
        /// SCI_GETCURLINE(position length, char *text NUL-terminated) -&gt; position<br/>
        /// This retrieves the text of the line containing the caret and returns the position within the line of the caret.
        /// Pass in char* text pointing at a buffer large enough to hold the text you wish to retrieve and a terminating
        /// NUL(0) character. Set length to the length of the buffer not including the terminating NUL character.
        /// If the text argument is NULL(0) then the length that should be allocated to store the entire current line is
        /// returned.
        /// </summary>
        SCI_GETCURLINE = 2027,
        /// <summary>
        /// SCI_GETENDSTYLED -&gt; position<br/>
        /// Scintilla keeps a record of the last character that is likely to be styled correctly. This is moved forwards when
        /// characters after it are styled and moved backwards if changes are made to the text of the document before it.
        /// Before drawing text, this position is checked to see if any styling is needed and, if so, a SCN_STYLENEEDED
        /// notification message is sent to the container. The container can send SCI_GETENDSTYLED to work out where it
        /// needs to start styling. Scintilla will always ask to style whole lines.
        /// </summary>
        SCI_GETENDSTYLED = 2028,
        SC_EOL_CRLF = 0,
        SC_EOL_CR = 1,
        SC_EOL_LF = 2,
        /// <summary>
        /// SCI_CONVERTEOLS(int eolMode)<br/>
        /// This message changes all the end of line characters in the document to match eolMode. Valid values are: SC_EOL_CRLF
        /// (0), SC_EOL_CR (1), or SC_EOL_LF (2).
        /// </summary>
        SCI_CONVERTEOLS = 2029,
        /// <summary>
        /// SCI_GETEOLMODE -&gt; int<br/>
        /// SCI_SETEOLMODE sets the characters that are added into the document when the user presses the Enter key. You can
        /// set eolMode to one of SC_EOL_CRLF (0), SC_EOL_CR (1), or SC_EOL_LF (2). The SCI_GETEOLMODE
        /// message retrieves the current state.
        /// </summary>
        SCI_GETEOLMODE = 2030,
        /// <summary>
        /// SCI_SETEOLMODE(int eolMode)<br/>
        /// </summary>
        SCI_SETEOLMODE = 2031,
        /// <summary>
        /// SCI_STARTSTYLING(position start, int unused)<br/>
        /// This prepares for styling by setting the styling position start to start at. The unused argument was used in
        /// earlier versions but is now ignored. After SCI_STARTSTYLING, send multiple SCI_SETSTYLING messages
        /// for each lexical entity to style or send SCI_SETSTYLINGEX to style in blocks.
        /// </summary>
        SCI_STARTSTYLING = 2032,
        /// <summary>
        /// SCI_SETSTYLING(position length, int style)<br/>
        /// This message sets the style of length characters starting at the styling position and then increases the styling
        /// position by length, ready for the next call. SCI_STARTSTYLING should be called before the first call to
        /// this.
        /// </summary>
        SCI_SETSTYLING = 2033,
        /// <summary>
        /// SCI_GETBUFFEREDDRAW -&gt; bool<br/>
        /// These messages turn buffered drawing on or off and report the buffered drawing state. Buffered drawing draws each
        /// line into a bitmap rather than directly to the screen and then copies the bitmap to the screen. This avoids
        /// flickering although it does take longer. The default is for drawing to be buffered on Win32 and GTK and to not be
        /// buffered on Cocoa and Qt. Buffered drawing is not supported on Cocoa.
        /// </summary>
        SCI_GETBUFFEREDDRAW = 2034,
        /// <summary>
        /// SCI_SETBUFFEREDDRAW(bool buffered)<br/>
        /// </summary>
        SCI_SETBUFFEREDDRAW = 2035,
        /// <summary>
        /// SCI_SETTABWIDTH(int tabWidth)<br/>
        /// </summary>
        SCI_SETTABWIDTH = 2036,
        /// <summary>
        /// SCI_GETTABWIDTH -&gt; int<br/>
        /// SCI_SETTABWIDTH sets the size of a tab as a multiple of the size of a space character in STYLE_DEFAULT. The
        /// default tab width is 8 characters. There are no limits on tab sizes, but values less than 1 or large values may
        /// have undesirable effects.
        /// </summary>
        SCI_GETTABWIDTH = 2121,
        /// <summary>
        /// SCI_SETTABMINIMUMWIDTH(int pixels)<br/>
        /// </summary>
        SCI_SETTABMINIMUMWIDTH = 2724,
        /// <summary>
        /// SCI_GETTABMINIMUMWIDTH -&gt; int<br/>
        /// SCI_SETTABMINIMUMWIDTH sets the minimum size of a tab in pixels to ensure that the tab can be seen. The default
        /// value is 2. This is particularly useful with proportional fonts with fractional widths where the character before
        /// the tab may end a fraction of a pixel before a tab stop, causing the tab to only be a fraction of a pixel wide
        /// without this setting. Where displaying a miniaturized version of the document, setting this to 0 may make the
        /// miniaturized version lay out more like the normal size version.
        /// </summary>
        SCI_GETTABMINIMUMWIDTH = 2725,
        /// <summary>
        /// SCI_CLEARTABSTOPS(line line)<br/>
        /// </summary>
        SCI_CLEARTABSTOPS = 2675,
        /// <summary>
        /// SCI_ADDTABSTOP(line line, int x)<br/>
        /// </summary>
        SCI_ADDTABSTOP = 2676,
        /// <summary>
        /// SCI_GETNEXTTABSTOP(line line, int x) -&gt; int<br/>
        /// SCI_CLEARTABSTOPS clears explicit tabstops on a line. SCI_ADDTABSTOP adds an explicit tabstop at the
        /// specified distance from the left (in pixels), and SCI_GETNEXTTABSTOP gets the next explicit tabstop position
        /// set after the given x position, or zero if there aren't any. Changing tab stops produces a
        /// SC_MOD_CHANGETABSTOPS notification.
        /// </summary>
        SCI_GETNEXTTABSTOP = 2677,
        SC_CP_UTF8 = 65001,
        /// <summary>
        /// SCI_SETCODEPAGE(int codePage)<br/>
        /// </summary>
        SCI_SETCODEPAGE = 2037,
        /// <summary>
        /// SCI_SETFONTLOCALE(&lt;unused&gt;, const char *localeName)<br/>
        /// </summary>
        SCI_SETFONTLOCALE = 2760,
        /// <summary>
        /// SCI_GETFONTLOCALE(&lt;unused&gt;, char *localeName NUL-terminated) -&gt; int<br/>
        /// These messages set the locale used for font selection with language-dependent glyphs. It may, depending on
        /// platform and other circumstances influence the display of text, so setting "zh-Hant" may result in traditional
        /// Chinese display and "zh-Hans" may result in simplified Chinese display. It is currently only implemented for Win32
        /// using DirectWrite where the value is passed as the localeName argument to CreateTextFormat. The default value is
        /// US English "en-us".
        /// </summary>
        SCI_GETFONTLOCALE = 2761,
        SC_IME_WINDOWED = 0,
        SC_IME_INLINE = 1,
        /// <summary>
        /// SCI_GETIMEINTERACTION -&gt; int<br/>
        /// When entering text in Chinese, Japanese, or Korean an Input Method Editor (IME) may be displayed. The IME may be
        /// an extra window appearing above Scintilla or may be displayed by Scintilla itself as text. On some platforms there
        /// is a choice between the two techniques. A windowed IME SC_IME_WINDOWED (0) may be more similar in appearance
        /// and behaviour to the IME in other applications. An inline IME SC_IME_INLINE (1) may work better with
        /// some Scintilla features such as rectangular and multiple selection, with IME interactions such as retrieve-
        /// surrounding or reconversion feature.
        /// </summary>
        SCI_GETIMEINTERACTION = 2678,
        /// <summary>
        /// SCI_SETIMEINTERACTION(int imeInteraction)<br/>
        /// </summary>
        SCI_SETIMEINTERACTION = 2679,
        SC_ALPHA_TRANSPARENT = 0,
        SC_ALPHA_OPAQUE = 255,
        SC_ALPHA_NOALPHA = 256,
        SC_CURSORNORMAL = 0xFFFFFFFF,
        SC_CURSORARROW = 2,
        SC_CURSORWAIT = 4,
        SC_CURSORREVERSEARROW = 7,
        MARKER_MAX = 31,
        SC_MARK_CIRCLE = 0,
        SC_MARK_ROUNDRECT = 1,
        SC_MARK_ARROW = 2,
        SC_MARK_SMALLRECT = 3,
        SC_MARK_SHORTARROW = 4,
        SC_MARK_EMPTY = 5,
        SC_MARK_ARROWDOWN = 6,
        SC_MARK_MINUS = 7,
        SC_MARK_PLUS = 8,
        SC_MARK_VLINE = 9,
        SC_MARK_LCORNER = 10,
        SC_MARK_TCORNER = 11,
        SC_MARK_BOXPLUS = 12,
        SC_MARK_BOXPLUSCONNECTED = 13,
        SC_MARK_BOXMINUS = 14,
        SC_MARK_BOXMINUSCONNECTED = 15,
        SC_MARK_LCORNERCURVE = 16,
        SC_MARK_TCORNERCURVE = 17,
        SC_MARK_CIRCLEPLUS = 18,
        SC_MARK_CIRCLEPLUSCONNECTED = 19,
        SC_MARK_CIRCLEMINUS = 20,
        SC_MARK_CIRCLEMINUSCONNECTED = 21,
        SC_MARK_BACKGROUND = 22,
        SC_MARK_DOTDOTDOT = 23,
        SC_MARK_ARROWS = 24,
        SC_MARK_PIXMAP = 25,
        SC_MARK_FULLRECT = 26,
        SC_MARK_LEFTRECT = 27,
        SC_MARK_AVAILABLE = 28,
        SC_MARK_UNDERLINE = 29,
        SC_MARK_RGBAIMAGE = 30,
        SC_MARK_BOOKMARK = 31,
        SC_MARK_VERTICALBOOKMARK = 32,
        SC_MARK_BAR = 33,
        SC_MARK_CHARACTER = 10000,
        SC_MARKNUM_HISTORY_REVERTED_TO_ORIGIN = 21,
        SC_MARKNUM_HISTORY_SAVED = 22,
        SC_MARKNUM_HISTORY_MODIFIED = 23,
        SC_MARKNUM_HISTORY_REVERTED_TO_MODIFIED = 24,
        SC_MARKNUM_FOLDEREND = 25,
        SC_MARKNUM_FOLDEROPENMID = 26,
        SC_MARKNUM_FOLDERMIDTAIL = 27,
        SC_MARKNUM_FOLDERTAIL = 28,
        SC_MARKNUM_FOLDERSUB = 29,
        SC_MARKNUM_FOLDER = 30,
        SC_MARKNUM_FOLDEROPEN = 31,
        SC_MASK_HISTORY = 0x01E00000,
        SC_MASK_FOLDERS = 0xFE000000,
        /// <summary>
        /// SCI_MARKERDEFINE(int markerNumber, int markerSymbol)<br/>
        /// This message associates a marker number in the range 0 to 31 with one of the marker symbols or an ASCII character.
        /// The general-purpose marker symbols currently available are: SC_MARK_CIRCLE, SC_MARK_ROUNDRECT ,
        /// SC_MARK_ARROW, SC_MARK_SMALLRECT, SC_MARK_SHORTARROW, SC_MARK_EMPTY ,
        /// SC_MARK_ARROWDOWN, SC_MARK_MINUS, SC_MARK_PLUS, SC_MARK_ARROWS, SC_MARK_DOTDOTDOT ,
        /// SC_MARK_BACKGROUND, SC_MARK_LEFTRECT, SC_MARK_FULLRECT, SC_MARK_BOOKMARK ,
        /// SC_MARK_VERTICALBOOKMARK, SC_MARK_UNDERLINE, and SC_MARK_BAR .
        /// </summary>
        SCI_MARKERDEFINE = 2040,
        /// <summary>
        /// SCI_MARKERSETFORE(int markerNumber, colour fore)<br/>
        /// </summary>
        SCI_MARKERSETFORE = 2041,
        /// <summary>
        /// SCI_MARKERSETBACK(int markerNumber, colour back)<br/>
        /// </summary>
        SCI_MARKERSETBACK = 2042,
        /// <summary>
        /// SCI_MARKERSETBACKSELECTED(int markerNumber, colour back)<br/>
        /// </summary>
        SCI_MARKERSETBACKSELECTED = 2292,
        /// <summary>
        /// SCI_MARKERSETFORETRANSLUCENT(int markerNumber, colouralpha fore)<br/>
        /// </summary>
        SCI_MARKERSETFORETRANSLUCENT = 2294,
        /// <summary>
        /// SCI_MARKERSETBACKTRANSLUCENT(int markerNumber, colouralpha back)<br/>
        /// These messages set the foreground and background colour of a marker number. The TRANSLUCENT variants can define
        /// different degrees of opacity.
        /// </summary>
        SCI_MARKERSETBACKTRANSLUCENT = 2295,
        /// <summary>
        /// SCI_MARKERSETBACKSELECTEDTRANSLUCENT(int markerNumber, colouralpha back)<br/>
        /// This message sets the highlight background colour of a marker number when its folding block is selected. The default
        /// colour is #FF0000.
        /// </summary>
        SCI_MARKERSETBACKSELECTEDTRANSLUCENT = 2296,
        /// <summary>
        /// SCI_MARKERSETSTROKEWIDTH(int markerNumber, int hundredths)<br/>
        /// This message sets the stroke width used to draw the marker in hundredths of a pixel. The default value is 100
        /// indicating a single pixel wide line.
        /// </summary>
        SCI_MARKERSETSTROKEWIDTH = 2297,
        /// <summary>
        /// SCI_MARKERENABLEHIGHLIGHT(bool enabled)<br/>
        /// This message allows to enable/disable the highlight folding block when it is selected. (i.e. block that contains the
        /// caret)
        /// </summary>
        SCI_MARKERENABLEHIGHLIGHT = 2293,
        /// <summary>
        /// SCI_MARKERADD(line line, int markerNumber) -&gt; int<br/>
        /// This message adds marker number markerNumber to a line. The message returns -1 if this fails (illegal line
        /// number, out of memory) or it returns a marker handle number that identifies the added marker. You can use this
        /// returned handle with SCI_MARKERLINEFROMHANDLE to find where a marker is after moving or combining lines
        /// and with SCI_MARKERDELETEHANDLE to delete the marker based on its handle. The message does not check the
        /// value of markerNumber, nor does it check if the line already contains the marker.
        /// </summary>
        SCI_MARKERADD = 2043,
        /// <summary>
        /// SCI_MARKERDELETE(line line, int markerNumber)<br/>
        /// This searches the given line number for the given marker number and deletes it if it is present. If you added the
        /// same marker more than once to the line, this will delete one copy each time it is used. If you pass in a marker
        /// number of -1, all markers are deleted from the line.
        /// </summary>
        SCI_MARKERDELETE = 2044,
        /// <summary>
        /// SCI_MARKERDELETEALL(int markerNumber)<br/>
        /// This removes markers of the given number from all lines. If markerNumber is -1, it deletes all markers from all
        /// lines.
        /// </summary>
        SCI_MARKERDELETEALL = 2045,
        /// <summary>
        /// SCI_MARKERGET(line line) -&gt; int<br/>
        /// This returns a 32-bit integer that indicates which markers were present on the line. Bit 0 is set if marker 0 is
        /// present, bit 1 for marker 1 and so on.
        /// </summary>
        SCI_MARKERGET = 2046,
        /// <summary>
        /// SCI_MARKERNEXT(line lineStart, int markerMask) -&gt; line<br/>
        /// </summary>
        SCI_MARKERNEXT = 2047,
        /// <summary>
        /// SCI_MARKERPREVIOUS(line lineStart, int markerMask) -&gt; line<br/>
        /// These messages search efficiently for lines that include a given set of markers. The search starts at line number
        /// lineStart and continues forwards to the end of the file( SCI_MARKERNEXT) or backwards to the start of the
        /// file( SCI_MARKERPREVIOUS ). The markerMask argument should have one bit set for each marker you wish to
        /// find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. The message returns the line number of the first
        /// line that contains one of the markers in markerMask or -1 if no marker is found.
        /// </summary>
        SCI_MARKERPREVIOUS = 2048,
        /// <summary>
        /// SCI_MARKERDEFINEPIXMAP(int markerNumber, const char *pixmap)<br/>
        /// Markers can be set to pixmaps with this message. The XPM format is used for the pixmap. Pixmaps use the
        /// SC_MARK_PIXMAP marker symbol.
        /// </summary>
        SCI_MARKERDEFINEPIXMAP = 2049,
        /// <summary>
        /// SCI_MARKERADDSET(line line, int markerSet)<br/>
        /// This message can add one or more markers to a line with a single call, specified in the same "one-bit-per-marker" 32-bit
        /// integer format returned by SCI_MARKERGET (and used by the mask-based marker search functions
        /// SCI_MARKERNEXT and SCI_MARKERPREVIOUS ). As with SCI_MARKERADD, no check is made to see if
        /// any of the markers are already present on the targeted line.
        /// </summary>
        SCI_MARKERADDSET = 2466,
        /// <summary>
        /// SCI_MARKERSETALPHA(int markerNumber, alpha alpha)<br/>
        /// When markers are drawn in the content area, either because there is no margin for them or they are of
        /// SC_MARK_BACKGROUND or SC_MARK_UNDERLINE types, they may be drawn translucently over text or opaquely on the
        /// base layer. The layer to draw on is defined by SCI_MARKERSETLAYER. The degree of translucency can be
        /// chosen by setting an alpha value. This is only for the content area- in margins, translucency is achieved through
        /// the SCI_MARKERSET…TRANSLUCENT methods. The layer argument can be one of:
        /// </summary>
        SCI_MARKERSETALPHA = 2476,
        /// <summary>
        /// SCI_MARKERGETLAYER(int markerNumber) -&gt; int<br/>
        /// </summary>
        SCI_MARKERGETLAYER = 2734,
        /// <summary>
        /// SCI_MARKERSETLAYER(int markerNumber, int layer)<br/>
        /// </summary>
        SCI_MARKERSETLAYER = 2735,
        SC_MAX_MARGIN = 4,
        SC_MARGIN_SYMBOL = 0,
        SC_MARGIN_NUMBER = 1,
        SC_MARGIN_BACK = 2,
        SC_MARGIN_FORE = 3,
        SC_MARGIN_TEXT = 4,
        SC_MARGIN_RTEXT = 5,
        SC_MARGIN_COLOUR = 6,
        /// <summary>
        /// SCI_SETMARGINTYPEN(int margin, int marginType)<br/>
        /// </summary>
        SCI_SETMARGINTYPEN = 2240,
        /// <summary>
        /// SCI_GETMARGINTYPEN(int margin) -&gt; int<br/>
        /// These two routines set and get the type of a margin. The margin argument should be 0, 1, 2, 3 or 4. You can use the
        /// predefined constants SC_MARGIN_SYMBOL (0) and SC_MARGIN_NUMBER (1) to set a margin as either a line number
        /// or a symbol margin. A margin with application defined text may use SC_MARGIN_TEXT (4) or SC_MARGIN_RTEXT
        /// (5) to right justify the text. By convention, margin 0 is used for line numbers and the next two are used for
        /// symbols. You can also use the constants SC_MARGIN_BACK (2), SC_MARGIN_FORE (3), and SC_MARGIN_COLOUR
        /// (6) for symbol margins that set their background colour to match the STYLE_DEFAULT background and foreground
        /// colours or a specified colour.
        /// </summary>
        SCI_GETMARGINTYPEN = 2241,
        /// <summary>
        /// SCI_SETMARGINWIDTHN(int margin, int pixelWidth)<br/>
        /// </summary>
        SCI_SETMARGINWIDTHN = 2242,
        /// <summary>
        /// SCI_GETMARGINWIDTHN(int margin) -&gt; int<br/>
        /// These routines set and get the width of a margin in pixels. A margin with zero width is invisible. By default,
        /// Scintilla sets margin 1 for symbols with a width of 16 pixels, so this is a reasonable guess if you are not sure
        /// what would be appropriate. Line number margins widths should take into account the number of lines in the document
        /// and the line number style. You could use something like SCI_TEXTWIDTH(STYLE_LINENUMBER, "_99999") to get a
        /// suitable width.
        /// </summary>
        SCI_GETMARGINWIDTHN = 2243,
        /// <summary>
        /// SCI_SETMARGINMASKN(int margin, int mask)<br/>
        /// </summary>
        SCI_SETMARGINMASKN = 2244,
        /// <summary>
        /// SCI_GETMARGINMASKN(int margin) -&gt; int<br/>
        /// The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that can be displayed in a margin
        /// that is enabled for symbols. There is a useful constant, SC_MASK_FOLDERS (0xFE000000 or -33554432), that is a mask
        /// for the 7 logical symbols used to denote folding, and another, SC_MASK_HISTORY (0x01E00000 or 31457280),
        /// that is a mask for the 4 logical symbols used to denote change history. You can assign a wide range of symbols and
        /// colours to each of the 32 logical symbols, see Markers for more information. If (mask &amp;
        /// SC_MASK_FOLDERS)==0, the margin background colour is controlled by style 33( STYLE_LINENUMBER ).
        /// </summary>
        SCI_GETMARGINMASKN = 2245,
        /// <summary>
        /// SCI_SETMARGINSENSITIVEN(int margin, bool sensitive)<br/>
        /// </summary>
        SCI_SETMARGINSENSITIVEN = 2246,
        /// <summary>
        /// SCI_GETMARGINSENSITIVEN(int margin) -&gt; bool<br/>
        /// Each of the five margins can be set sensitive or insensitive to mouse clicks. A click in a sensitive margin sends a
        /// SCN_MARGINCLICK or SCN_MARGINRIGHTCLICK notification to the container. Margins that are not sensitive act as
        /// selection margins which make it easy to select ranges of lines. By default, all margins are insensitive.
        /// </summary>
        SCI_GETMARGINSENSITIVEN = 2247,
        /// <summary>
        /// SCI_SETMARGINCURSORN(int margin, int cursor)<br/>
        /// </summary>
        SCI_SETMARGINCURSORN = 2248,
        /// <summary>
        /// SCI_GETMARGINCURSORN(int margin) -&gt; int<br/>
        /// A reversed arrow cursor is normally shown over all margins. This may be changed to a normal arrow with
        /// SCI_SETMARGINCURSORN(margin, SC_CURSORARROW) or restored to a reversed arrow with
        /// SCI_SETMARGINCURSORN(margin, SC_CURSORREVERSEARROW) .
        /// </summary>
        SCI_GETMARGINCURSORN = 2249,
        /// <summary>
        /// SCI_SETMARGINBACKN(int margin, colour back)<br/>
        /// </summary>
        SCI_SETMARGINBACKN = 2250,
        /// <summary>
        /// SCI_GETMARGINBACKN(int margin) -&gt; colour<br/>
        /// A margin of type SC_MARGIN_COLOUR may have its colour set with SCI_SETMARGINBACKN .
        /// </summary>
        SCI_GETMARGINBACKN = 2251,
        /// <summary>
        /// SCI_SETMARGINS(int margins)<br/>
        /// </summary>
        SCI_SETMARGINS = 2252,
        /// <summary>
        /// SCI_GETMARGINS -&gt; int<br/>
        /// Allocate the number of margins or find the number of margins currently allocated.
        /// </summary>
        SCI_GETMARGINS = 2253,
        STYLE_DEFAULT = 32,
        STYLE_LINENUMBER = 33,
        STYLE_BRACELIGHT = 34,
        STYLE_BRACEBAD = 35,
        STYLE_CONTROLCHAR = 36,
        STYLE_INDENTGUIDE = 37,
        STYLE_CALLTIP = 38,
        STYLE_FOLDDISPLAYTEXT = 39,
        STYLE_LASTPREDEFINED = 39,
        STYLE_MAX = 255,
        SC_CHARSET_ANSI = 0,
        SC_CHARSET_DEFAULT = 1,
        SC_CHARSET_BALTIC = 186,
        SC_CHARSET_CHINESEBIG5 = 136,
        SC_CHARSET_EASTEUROPE = 238,
        SC_CHARSET_GB2312 = 134,
        SC_CHARSET_GREEK = 161,
        SC_CHARSET_HANGUL = 129,
        SC_CHARSET_MAC = 77,
        SC_CHARSET_OEM = 255,
        SC_CHARSET_RUSSIAN = 204,
        SC_CHARSET_OEM866 = 866,
        SC_CHARSET_CYRILLIC = 1251,
        SC_CHARSET_SHIFTJIS = 128,
        SC_CHARSET_SYMBOL = 2,
        SC_CHARSET_TURKISH = 162,
        SC_CHARSET_JOHAB = 130,
        SC_CHARSET_HEBREW = 177,
        SC_CHARSET_ARABIC = 178,
        SC_CHARSET_VIETNAMESE = 163,
        SC_CHARSET_THAI = 222,
        SC_CHARSET_8859_15 = 1000,
        SCI_STYLECLEARALL = 2050,
        /// <summary>
        /// SCI_STYLESETFORE(int style, colour fore)<br/>
        /// </summary>
        SCI_STYLESETFORE = 2051,
        /// <summary>
        /// SCI_STYLESETBACK(int style, colour back)<br/>
        /// </summary>
        SCI_STYLESETBACK = 2052,
        /// <summary>
        /// SCI_STYLESETBOLD(int style, bool bold)<br/>
        /// </summary>
        SCI_STYLESETBOLD = 2053,
        /// <summary>
        /// SCI_STYLESETITALIC(int style, bool italic)<br/>
        /// </summary>
        SCI_STYLESETITALIC = 2054,
        /// <summary>
        /// SCI_STYLESETSIZE(int style, int sizePoints)<br/>
        /// </summary>
        SCI_STYLESETSIZE = 2055,
        /// <summary>
        /// SCI_STYLESETFONT(int style, const char *fontName)<br/>
        /// </summary>
        SCI_STYLESETFONT = 2056,
        /// <summary>
        /// SCI_STYLESETEOLFILLED(int style, bool eolFilled)<br/>
        /// </summary>
        SCI_STYLESETEOLFILLED = 2057,
        SCI_STYLERESETDEFAULT = 2058,
        /// <summary>
        /// SCI_STYLESETUNDERLINE(int style, bool underline)<br/>
        /// </summary>
        SCI_STYLESETUNDERLINE = 2059,
        SC_CASE_MIXED = 0,
        SC_CASE_UPPER = 1,
        SC_CASE_LOWER = 2,
        SC_CASE_CAMEL = 3,
        /// <summary>
        /// SCI_STYLEGETFORE(int style) -&gt; colour<br/>
        /// </summary>
        SCI_STYLEGETFORE = 2481,
        /// <summary>
        /// SCI_STYLEGETBACK(int style) -&gt; colour<br/>
        /// Text is drawn in the foreground colour. The space in each character cell that is not occupied by the character is
        /// drawn in the background colour.
        /// </summary>
        SCI_STYLEGETBACK = 2482,
        /// <summary>
        /// SCI_STYLEGETBOLD(int style) -&gt; bool<br/>
        /// </summary>
        SCI_STYLEGETBOLD = 2483,
        /// <summary>
        /// SCI_STYLEGETITALIC(int style) -&gt; bool<br/>
        /// These messages (plus SCI_STYLESETCHARACTERSET) set the font attributes that are used to match the fonts you
        /// request to those available.
        /// </summary>
        SCI_STYLEGETITALIC = 2484,
        /// <summary>
        /// SCI_STYLEGETSIZE(int style) -&gt; int<br/>
        /// </summary>
        SCI_STYLEGETSIZE = 2485,
        /// <summary>
        /// SCI_STYLEGETFONT(int style, char *fontName NUL-terminated) -&gt; int<br/>
        /// </summary>
        SCI_STYLEGETFONT = 2486,
        /// <summary>
        /// SCI_STYLEGETEOLFILLED(int style) -&gt; bool<br/>
        /// If the last character in the line has a style with this attribute set, the remainder of the line up to the right
        /// edge of the window is filled with the background colour set for the last character. This is useful when a document
        /// contains embedded sections in another language such as HTML pages with embedded JavaScript. By setting eolFilled
        /// to true and a consistent background colour (different from the background colour set for the HTML styles)
        /// to all JavaScript styles then JavaScript sections will be easily distinguished from HTML.
        /// </summary>
        SCI_STYLEGETEOLFILLED = 2487,
        /// <summary>
        /// SCI_STYLEGETUNDERLINE(int style) -&gt; bool<br/>
        /// You can set a style to be underlined. The underline is drawn in the foreground colour. All characters with a style
        /// that includes the underline attribute are underlined, even if they are white space.
        /// </summary>
        SCI_STYLEGETUNDERLINE = 2488,
        /// <summary>
        /// SCI_STYLEGETCASE(int style) -&gt; int<br/>
        /// The value of caseVisible determines how text is displayed. You can set upper case( SC_CASE_UPPER, 1) or
        /// lower case( SC_CASE_LOWER, 2) or camel case( SC_CASE_CAMEL, 3) or display normally( SC_CASE_MIXED, 0).
        /// This does not change the stored text, only how it is displayed.
        /// </summary>
        SCI_STYLEGETCASE = 2489,
        /// <summary>
        /// SCI_STYLEGETCHARACTERSET(int style) -&gt; int<br/>
        /// You can set a style to use a different character set than the default. The places where such characters sets are
        /// likely to be useful are comments and literal strings. For example, SCI_STYLESETCHARACTERSET(SCE_C_STRING,
        /// SC_CHARSET_RUSSIAN) would ensure that strings in Russian would display correctly in C and C++( SCE_C_STRING
        /// is the style number used by the C and C++ lexer to display literal strings; it has the value 6). This feature
        /// works differently on Windows and GTK. The default character set is SC_CHARSET_DEFAULT .
        /// </summary>
        SCI_STYLEGETCHARACTERSET = 2490,
        /// <summary>
        /// SCI_STYLEGETVISIBLE(int style) -&gt; bool<br/>
        /// Text is normally visible. However, you can completely hide it by giving it a style with the visible set to 0. This
        /// could be used to hide embedded formatting instructions or hypertext keywords in HTML or XML. Invisible text
        /// may not be deleted by user actions but the application may delete invisible text by calling SCI_DELETERANGE .
        /// </summary>
        SCI_STYLEGETVISIBLE = 2491,
        /// <summary>
        /// SCI_STYLEGETCHANGEABLE(int style) -&gt; bool<br/>
        /// This is an experimental and incompletely implemented style attribute. The default setting is changeable set true
        /// but when set false it makes text read-only. The user can not move the caret within not-changeable text and not-
        /// changeable text may not be deleted by the user. The application may delete not-changeable text by calling
        /// SCI_DELETERANGE .
        /// </summary>
        SCI_STYLEGETCHANGEABLE = 2492,
        /// <summary>
        /// SCI_STYLEGETHOTSPOT(int style) -&gt; bool<br/>
        /// This style is used to mark ranges of text that can detect mouse clicks. The cursor changes to a hand over hotspots,
        /// and the foreground, and background colours may change and an underline appear to indicate that these areas are
        /// sensitive to clicking. This may be used to allow hyperlinks to other documents.
        /// </summary>
        SCI_STYLEGETHOTSPOT = 2493,
        /// <summary>
        /// SCI_STYLESETCASE(int style, int caseVisible)<br/>
        /// </summary>
        SCI_STYLESETCASE = 2060,
        SC_FONT_SIZE_MULTIPLIER = 100,
        /// <summary>
        /// SCI_STYLESETSIZEFRACTIONAL(int style, int sizeHundredthPoints)<br/>
        /// </summary>
        SCI_STYLESETSIZEFRACTIONAL = 2061,
        /// <summary>
        /// SCI_STYLEGETSIZEFRACTIONAL(int style) -&gt; int<br/>
        /// </summary>
        SCI_STYLEGETSIZEFRACTIONAL = 2062,
        SC_WEIGHT_NORMAL = 400,
        SC_WEIGHT_SEMIBOLD = 600,
        SC_WEIGHT_BOLD = 700,
        /// <summary>
        /// SCI_STYLESETWEIGHT(int style, int weight)<br/>
        /// </summary>
        SCI_STYLESETWEIGHT = 2063,
        /// <summary>
        /// SCI_STYLEGETWEIGHT(int style) -&gt; int<br/>
        /// </summary>
        SCI_STYLEGETWEIGHT = 2064,
        /// <summary>
        /// SCI_STYLESETCHARACTERSET(int style, int characterSet)<br/>
        /// </summary>
        SCI_STYLESETCHARACTERSET = 2066,
        /// <summary>
        /// SCI_STYLESETHOTSPOT(int style, bool hotspot)<br/>
        /// </summary>
        SCI_STYLESETHOTSPOT = 2409,
        /// <summary>
        /// SCI_STYLESETCHECKMONOSPACED(int style, bool checkMonospaced)<br/>
        /// </summary>
        SCI_STYLESETCHECKMONOSPACED = 2254,
        /// <summary>
        /// SCI_STYLEGETCHECKMONOSPACED(int style) -&gt; bool<br/>
        /// This attribute indicates that the font may be monospaced over the ASCII graphics characters ('' … '~', including
        /// letters ('a'…'z', 'A'…'Z') and numbers ('0'…'9')). This allows optimizing speed and memory use for some common
        /// scenarios where documents are mostly composed from ASCII characters.
        /// </summary>
        SCI_STYLEGETCHECKMONOSPACED = 2255,
        SC_STRETCH_ULTRA_CONDENSED = 1,
        SC_STRETCH_EXTRA_CONDENSED = 2,
        SC_STRETCH_CONDENSED = 3,
        SC_STRETCH_SEMI_CONDENSED = 4,
        SC_STRETCH_NORMAL = 5,
        SC_STRETCH_SEMI_EXPANDED = 6,
        SC_STRETCH_EXPANDED = 7,
        SC_STRETCH_EXTRA_EXPANDED = 8,
        SC_STRETCH_ULTRA_EXPANDED = 9,
        /// <summary>
        /// SCI_STYLESETSTRETCH(int style, int stretch)<br/>
        /// </summary>
        SCI_STYLESETSTRETCH = 2258,
        /// <summary>
        /// SCI_STYLEGETSTRETCH(int style) -&gt; int<br/>
        /// </summary>
        SCI_STYLEGETSTRETCH = 2259,
        /// <summary>
        /// SCI_STYLESETINVISIBLEREPRESENTATION(int style, const char *representation)<br/>
        /// </summary>
        SCI_STYLESETINVISIBLEREPRESENTATION = 2256,
        /// <summary>
        /// SCI_STYLEGETINVISIBLEREPRESENTATION(int style, char *representation NUL-terminated) -&gt; int<br/>
        /// When a style is made invisible with SCI_STYLESETVISIBLE, text is difficult to edit as the cursor can be at both
        /// sides of the invisible text segment. With these messages invisible text segements can be made visible with a single
        /// UTF8 characater giving the user an indication if the cursor is left or right of the invisible text. The character is
        /// displayed using the current style.
        /// </summary>
        SCI_STYLEGETINVISIBLEREPRESENTATION = 2257,
        /// <summary>
        /// SC_ELEMENT_LIST : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_LIST = 0,
        /// <summary>
        /// SC_ELEMENT_LIST_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_LIST_BACK = 1,
        /// <summary>
        /// SC_ELEMENT_LIST_SELECTED : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_LIST_SELECTED = 2,
        /// <summary>
        /// SC_ELEMENT_LIST_SELECTED_BACK : colouralpha<br/>
        /// The colours used for autocompletion lists may be customised on Win32 using SCI_SETELEMENTCOLOUR .
        /// </summary>
        SC_ELEMENT_LIST_SELECTED_BACK = 3,
        /// <summary>
        /// SC_ELEMENT_SELECTION_TEXT : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_TEXT = 10,
        /// <summary>
        /// SC_ELEMENT_SELECTION_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_BACK = 11,
        /// <summary>
        /// SC_ELEMENT_SELECTION_ADDITIONAL_TEXT : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_ADDITIONAL_TEXT = 12,
        /// <summary>
        /// SC_ELEMENT_SELECTION_ADDITIONAL_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_ADDITIONAL_BACK = 13,
        /// <summary>
        /// SC_ELEMENT_SELECTION_SECONDARY_TEXT : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_SECONDARY_TEXT = 14,
        /// <summary>
        /// SC_ELEMENT_SELECTION_SECONDARY_BACK : colouralpha<br/>
        /// On Unix systems running with the X window system or Wayland there is a 'primary selection' which is the text most
        /// recently selected in any application and which can be pasted by a middle button click. When working with a
        /// selection, it is commonly the primary selection so Scintilla draws the primary selection with the main and additional
        /// colours defined earlier. When another application takes over the primary selection, these _SECONDARY colours are
        /// used. They are commonly defined as grey to highlight that it is the selection in the other application that is now
        /// available as primary.
        /// </summary>
        SC_ELEMENT_SELECTION_SECONDARY_BACK = 15,
        /// <summary>
        /// SC_ELEMENT_SELECTION_INACTIVE_TEXT : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_INACTIVE_TEXT = 16,
        /// <summary>
        /// SC_ELEMENT_SELECTION_INACTIVE_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_INACTIVE_BACK = 17,
        /// <summary>
        /// SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_TEXT : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_TEXT = 18,
        /// <summary>
        /// SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_BACK : colouralpha<br/>
        /// When a window no longer has the keyboard focus, it is customary to make its selection less noticeable by colouring it
        /// grey. These elements define the colours to be used for selections without focus. When the ADDITIONAL elements
        /// are not set then the standard values are used: SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_TEXT -&gt;
        /// SC_ELEMENT_SELECTION_INACTIVE_TEXT and SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_BACK -&gt;
        /// SC_ELEMENT_SELECTION_INACTIVE_BACK .
        /// </summary>
        SC_ELEMENT_SELECTION_INACTIVE_ADDITIONAL_BACK = 19,
        /// <summary>
        /// SC_ELEMENT_CARET : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_CARET = 40,
        /// <summary>
        /// SC_ELEMENT_CARET_ADDITIONAL : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_CARET_ADDITIONAL = 41,
        /// <summary>
        /// SC_ELEMENT_CARET_LINE_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_CARET_LINE_BACK = 50,
        /// <summary>
        /// SC_ELEMENT_WHITE_SPACE : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_WHITE_SPACE = 60,
        /// <summary>
        /// SC_ELEMENT_WHITE_SPACE_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_WHITE_SPACE_BACK = 61,
        /// <summary>
        /// SC_ELEMENT_HOT_SPOT_ACTIVE : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_HOT_SPOT_ACTIVE = 70,
        /// <summary>
        /// SC_ELEMENT_HOT_SPOT_ACTIVE_BACK : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_HOT_SPOT_ACTIVE_BACK = 71,
        /// <summary>
        /// SC_ELEMENT_FOLD_LINE : colouralpha<br/>
        /// In addition to showing markers in the folding margin, you can indicate folds to the user by drawing lines in the
        /// text area. The lines are drawn in the SC_ELEMENT_FOLD_LINE colour if set. If it is not set then the
        /// foreground colour set for STYLE_DEFAULT is used. Bits set in flags determine where folding lines are
        /// drawn:
        /// </summary>
        SC_ELEMENT_FOLD_LINE = 80,
        /// <summary>
        /// SC_ELEMENT_HIDDEN_LINE : colouralpha<br/>
        /// </summary>
        SC_ELEMENT_HIDDEN_LINE = 81,
        /// <summary>
        /// SCI_SETELEMENTCOLOUR(int element, colouralpha colourElement)<br/>
        /// </summary>
        SCI_SETELEMENTCOLOUR = 2753,
        /// <summary>
        /// SCI_GETELEMENTCOLOUR(int element) -&gt; colouralpha<br/>
        /// This changes the colour of the indicated visual element overriding any current colour. If the element supports
        /// translucency, then the alpha portion of the value is used. An opaque alpha value (0xff) should always be included
        /// when an opaque colour is desired as the value 0 is completely transparent and thus invisible.
        /// </summary>
        SCI_GETELEMENTCOLOUR = 2754,
        /// <summary>
        /// SCI_RESETELEMENTCOLOUR(int element)<br/>
        /// This removes the element colour returning to the default colour or set of colours.
        /// </summary>
        SCI_RESETELEMENTCOLOUR = 2755,
        /// <summary>
        /// SCI_GETELEMENTISSET(int element) -&gt; bool<br/>
        /// Returns true when an element colour has been set. When false indicates that a default colour or set of colours is
        /// displayed.
        /// </summary>
        SCI_GETELEMENTISSET = 2756,
        /// <summary>
        /// SCI_GETELEMENTALLOWSTRANSLUCENT(int element) -&gt; bool<br/>
        /// Returns true when the element currently allows translucent drawing when an alpha component is included. This may
        /// change based on circumstances- different platforms or graphics technologies may implement translucency and newer
        /// versions of Scintilla may implement translucency for elements that did not previously support it.
        /// </summary>
        SCI_GETELEMENTALLOWSTRANSLUCENT = 2757,
        /// <summary>
        /// SCI_GETELEMENTBASECOLOUR(int element) -&gt; colouralpha<br/>
        /// Returns the default colour of an element. This may be a value defined by Scintilla or it may be derived from the
        /// operating system or platform. Which values are set from the operating system may differ between operating systems
        /// and operating system versions. When undefined the return value is 0 which is equivalent to completely transparent
        /// black. These colours may be useful when defining styles with similarities such as synthesizing dark mode
        /// styles that use the same colours as the system
        /// </summary>
        SCI_GETELEMENTBASECOLOUR = 2758,
        /// <summary>
        /// SCI_SETSELFORE(bool useSetting, colour fore)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETSELFORE = 2067,
        /// <summary>
        /// SCI_SETSELBACK(bool useSetting, colour back)<br/>
        /// You can choose to override the default selection colouring with these elements and messages. The element APIs
        /// are now preferred as they handle translucency+ layering and cooperation with defaults better. With the
        /// messages, the colour you provide is used if you set useSetting to true. If it is set to false, the
        /// default styled colouring is used and the fore or back argument has no effect.
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETSELBACK = 2068,
        /// <summary>
        /// SCI_GETSELALPHA -&gt; int<br/>
        /// These APIs are now discouraged and should be replaced with a combination of setting the layer with
        /// SCI_SETSELECTIONLAYER and setting translucency through the SC_ELEMENT_SELECTION_BACK element.
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETSELALPHA = 2477,
        /// <summary>
        /// SCI_SETSELALPHA( alpha alpha)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETSELALPHA = 2478,
        /// <summary>
        /// SCI_GETSELEOLFILLED -&gt; bool<br/>
        /// The selection can be drawn up to the right hand border by setting this property.
        /// </summary>
        SCI_GETSELEOLFILLED = 2479,
        /// <summary>
        /// SCI_SETSELEOLFILLED(bool filled)<br/>
        /// </summary>
        SCI_SETSELEOLFILLED = 2480,
        SC_LAYER_BASE = 0,
        SC_LAYER_UNDER_TEXT = 1,
        SC_LAYER_OVER_TEXT = 2,
        /// <summary>
        /// SCI_GETSELECTIONLAYER -&gt; int<br/>
        /// The selection background can be drawn translucently over the text or opaquely on the base layer. The layer
        /// argument can be one of:
        /// </summary>
        SCI_GETSELECTIONLAYER = 2762,
        /// <summary>
        /// SCI_SETSELECTIONLAYER(int layer)<br/>
        /// </summary>
        SCI_SETSELECTIONLAYER = 2763,
        /// <summary>
        /// SCI_GETCARETLINELAYER -&gt; int<br/>
        /// You can choose to make the background colour of the line containing the caret different by setting the
        /// SC_ELEMENT_CARET_LINE_BACK element with SCI_SETELEMENTCOLOUR(SC_ELEMENT_CARET_LINE_BACK). This effect
        /// may be drawn translucently over the text or opaquely on the base layer with SCI_SETCARETLINELAYER. Background
        /// colouring has highest priority when a line has markers that would otherwise change the background colour. When
        /// drawn translucently other background colours can show through. The layer argument can be one of:
        /// </summary>
        SCI_GETCARETLINELAYER = 2764,
        /// <summary>
        /// SCI_SETCARETLINELAYER(int layer)<br/>
        /// </summary>
        SCI_SETCARETLINELAYER = 2765,
        /// <summary>
        /// SCI_GETCARETLINEHIGHLIGHTSUBLINE -&gt; bool<br/>
        /// Choose to highlight only the subline containing the caret instead of the whole line. Default behaviour
        /// SCI_SETCARETLINEHIGHLIGHTSUBLINE(false) the whole caret line is highlighted.
        /// </summary>
        SCI_GETCARETLINEHIGHLIGHTSUBLINE = 2773,
        /// <summary>
        /// SCI_SETCARETLINEHIGHLIGHTSUBLINE(bool subLine)<br/>
        /// </summary>
        SCI_SETCARETLINEHIGHLIGHTSUBLINE = 2774,
        /// <summary>
        /// SCI_SETCARETFORE( colour fore)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETCARETFORE = 2069,
        /// <summary>
        /// SCI_ASSIGNCMDKEY(int keyDefinition , int sciCommand)<br/>
        /// This assigns the given key definition to a Scintilla command identified by sciCommand. sciCommand can be any
        /// SCI_* command that has no arguments.
        /// </summary>
        SCI_ASSIGNCMDKEY = 2070,
        /// <summary>
        /// SCI_CLEARCMDKEY(int keyDefinition )<br/>
        /// This makes the given key definition do nothing by assigning the action SCI_NULL to it.
        /// </summary>
        SCI_CLEARCMDKEY = 2071,
        SCI_CLEARALLCMDKEYS = 2072,
        /// <summary>
        /// SCI_SETSTYLINGEX(position length, const char *styles)<br/>
        /// As an alternative to SCI_SETSTYLING, which applies the same style to each byte, you can use this message which
        /// specifies the styles for each of length bytes from the styling position and then increases the styling position
        /// by length, ready for the next call. SCI_STARTSTYLING should be called before the first call to this.
        /// </summary>
        SCI_SETSTYLINGEX = 2073,
        /// <summary>
        /// SCI_STYLESETVISIBLE(int style, bool visible)<br/>
        /// </summary>
        SCI_STYLESETVISIBLE = 2074,
        /// <summary>
        /// SCI_GETCARETPERIOD -&gt; int<br/>
        /// The rate at which the caret blinks can be set with SCI_SETCARETPERIOD which determines the time in milliseconds
        /// that the caret is visible or invisible before changing state. Setting the period to 0 stops the caret blinking. The
        /// default value is 500 milliseconds. SCI_GETCARETPERIOD returns the current setting.
        /// </summary>
        SCI_GETCARETPERIOD = 2075,
        /// <summary>
        /// SCI_SETCARETPERIOD(int periodMilliseconds)<br/>
        /// </summary>
        SCI_SETCARETPERIOD = 2076,
        /// <summary>
        /// SCI_SETWORDCHARS(&lt;unused&gt;, const char *characters)<br/>
        /// This message defines which characters are members of the word category. The character categories are set to
        /// default values before processing this function. For example, if you don't allow '_' in your set of characters
        /// use: SCI_SETWORDCHARS(0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") ;
        /// </summary>
        SCI_SETWORDCHARS = 2077,
        /// <summary>
        /// SCI_GETWORDCHARS(&lt;unused&gt;, char *characters) -&gt; int<br/>
        /// This fills the characters parameter with all the characters included in words. The characters parameter
        /// must be large enough to hold all of the characters. If the characters parameter is 0 then the length that
        /// should be allocated to store the entire set is returned.
        /// </summary>
        SCI_GETWORDCHARS = 2646,
        /// <summary>
        /// SCI_SETCHARACTERCATEGORYOPTIMIZATION(int countCharacters)<br/>
        /// </summary>
        SCI_SETCHARACTERCATEGORYOPTIMIZATION = 2720,
        /// <summary>
        /// SCI_GETCHARACTERCATEGORYOPTIMIZATION -&gt; int<br/>
        /// Optimize speed of character category features like determining whether a character is a space or number at the expense
        /// of memory. Mostly used for Unicode documents. The countCharacters parameter determines how many
        /// character starting from 0 are added to a look-up table with one byte used for each character. It is reasonable to
        /// cover the set of characters likely to be used in a document so 0x100 for simple Roman text, 0x1000 to cover most
        /// simple alphabets, 0x10000 to cover most of East Asian languages, and 0x110000 to cover all possible characters.
        /// </summary>
        SCI_GETCHARACTERCATEGORYOPTIMIZATION = 2721,
        SCI_BEGINUNDOACTION = 2078,
        SCI_ENDUNDOACTION = 2079,
        /// <summary>
        /// SCI_GETUNDOSEQUENCE -&gt; int<br/>
        /// Determine if an undo sequence is active with a positive value indicating that a sequence is active and 0 that there is
        /// no current sequence. The value returned is the nesting depth of the sequence, that is, the number of times
        /// SCI_BEGINUNDOACTION was called without a correspnding SCI_ENDUNDOACTION. A negative value indicates an
        /// error.
        /// </summary>
        SCI_GETUNDOSEQUENCE = 2799,
        SCI_GETUNDOACTIONS = 2790,
        SCI_SETUNDOSAVEPOINT = 2791,
        SCI_GETUNDOSAVEPOINT = 2792,
        SCI_SETUNDODETACH = 2793,
        SCI_GETUNDODETACH = 2794,
        SCI_SETUNDOTENTATIVE = 2795,
        SCI_GETUNDOTENTATIVE = 2796,
        SCI_SETUNDOCURRENT = 2797,
        SCI_GETUNDOCURRENT = 2798,
        SCI_PUSHUNDOACTIONTYPE = 2800,
        SCI_CHANGELASTUNDOACTIONTEXT = 2801,
        SCI_GETUNDOACTIONTYPE = 2802,
        SCI_GETUNDOACTIONPOSITION = 2803,
        SCI_GETUNDOACTIONTEXT = 2804,
        INDIC_PLAIN = 0,
        INDIC_SQUIGGLE = 1,
        INDIC_TT = 2,
        INDIC_DIAGONAL = 3,
        INDIC_STRIKE = 4,
        INDIC_HIDDEN = 5,
        INDIC_BOX = 6,
        INDIC_ROUNDBOX = 7,
        INDIC_STRAIGHTBOX = 8,
        INDIC_DASH = 9,
        INDIC_DOTS = 10,
        INDIC_SQUIGGLELOW = 11,
        INDIC_DOTBOX = 12,
        INDIC_SQUIGGLEPIXMAP = 13,
        INDIC_COMPOSITIONTHICK = 14,
        INDIC_COMPOSITIONTHIN = 15,
        INDIC_FULLBOX = 16,
        INDIC_TEXTFORE = 17,
        INDIC_POINT = 18,
        INDIC_POINTCHARACTER = 19,
        INDIC_GRADIENT = 20,
        INDIC_GRADIENTCENTRE = 21,
        INDIC_POINT_TOP = 22,
        INDIC_EXPLORERLINK = 23,
        INDIC_CONTAINER = 8,
        INDIC_IME = 32,
        INDIC_IME_MAX = 35,
        INDIC_MAX = 35,
        INDICATOR_CONTAINER = 8,
        INDICATOR_IME = 32,
        INDICATOR_IME_MAX = 35,
        INDICATOR_HISTORY_REVERTED_TO_ORIGIN_INSERTION = 36,
        INDICATOR_HISTORY_REVERTED_TO_ORIGIN_DELETION = 37,
        INDICATOR_HISTORY_SAVED_INSERTION = 38,
        INDICATOR_HISTORY_SAVED_DELETION = 39,
        INDICATOR_HISTORY_MODIFIED_INSERTION = 40,
        INDICATOR_HISTORY_MODIFIED_DELETION = 41,
        INDICATOR_HISTORY_REVERTED_TO_MODIFIED_INSERTION = 42,
        INDICATOR_HISTORY_REVERTED_TO_MODIFIED_DELETION = 43,
        INDICATOR_MAX = 43,
        /// <summary>
        /// SCI_INDICSETSTYLE(int indicator, int indicatorStyle)<br/>
        /// </summary>
        SCI_INDICSETSTYLE = 2080,
        /// <summary>
        /// SCI_INDICGETSTYLE(int indicator) -&gt; int<br/>
        /// These two messages set and get the style for a particular indicator. The indicator styles currently available are:
        /// </summary>
        SCI_INDICGETSTYLE = 2081,
        /// <summary>
        /// SCI_INDICSETFORE(int indicator, colour fore)<br/>
        /// </summary>
        SCI_INDICSETFORE = 2082,
        /// <summary>
        /// SCI_INDICGETFORE(int indicator) -&gt; colour<br/>
        /// These two messages set and get the colour used to draw an indicator. The default indicator colours are equivalent
        /// to: SCI_INDICSETFORE(0, 0x007f00); (dark green) SCI_INDICSETFORE(1, 0xff0000); (light blue)
        /// SCI_INDICSETFORE(2, 0x0000ff); (light red)
        /// </summary>
        SCI_INDICGETFORE = 2083,
        /// <summary>
        /// SCI_INDICSETUNDER(int indicator, bool under)<br/>
        /// </summary>
        SCI_INDICSETUNDER = 2510,
        /// <summary>
        /// SCI_INDICGETUNDER(int indicator) -&gt; bool<br/>
        /// These two messages set and get whether an indicator is drawn under text or over(default). Drawing under text does
        /// not work with the deprecated single phase drawing mode.
        /// </summary>
        SCI_INDICGETUNDER = 2511,
        /// <summary>
        /// SCI_INDICSETHOVERSTYLE(int indicator, int indicatorStyle)<br/>
        /// </summary>
        SCI_INDICSETHOVERSTYLE = 2680,
        /// <summary>
        /// SCI_INDICGETHOVERSTYLE(int indicator) -&gt; int<br/>
        /// </summary>
        SCI_INDICGETHOVERSTYLE = 2681,
        /// <summary>
        /// SCI_INDICSETHOVERFORE(int indicator, colour fore)<br/>
        /// </summary>
        SCI_INDICSETHOVERFORE = 2682,
        /// <summary>
        /// SCI_INDICGETHOVERFORE(int indicator) -&gt; colour<br/>
        /// These messages set and get the colour and style used to draw indicators when the mouse is over them or the caret moved
        /// into them. The mouse cursor also changes when an indicator is drawn in hover style. The default is for the
        /// hover appearance to be the same as the normal appearance and calling SCI_INDICSETFORE or SCI_INDICSETSTYLE will
        /// also reset the hover attribute.
        /// </summary>
        SCI_INDICGETHOVERFORE = 2683,
        SC_INDICVALUEBIT = 0x1000000,
        SC_INDICVALUEMASK = 0xFFFFFF,
        SC_INDICFLAG_NONE = 0,
        SC_INDICFLAG_VALUEFORE = 1,
        /// <summary>
        /// SCI_INDICSETFLAGS(int indicator, int flags)<br/>
        /// </summary>
        SCI_INDICSETFLAGS = 2684,
        /// <summary>
        /// SCI_INDICGETFLAGS(int indicator) -&gt; int<br/>
        /// These messages set and get the flags associated with an indicator. There is currently one flag defined,
        /// SC_INDICFLAG_VALUEFORE: when this flag is set the colour used by the indicator is not from the indicator's fore
        /// setting but instead from the value of the indicator at that point in the file. SC_INDICFLAG_NONE is the
        /// default. This allows many colours to be displayed for a single indicator. The value is an RGB integer colour
        /// that has been ored with SC_INDICVALUEBIT (0x1000000) when calling SCI_SETINDICATORVALUE. To find the
        /// colour from the value, and the value with SC_INDICVALUEMASK (0xFFFFFF).
        /// </summary>
        SCI_INDICGETFLAGS = 2685,
        /// <summary>
        /// SCI_INDICSETSTROKEWIDTH(int indicator, int hundredths)<br/>
        /// </summary>
        SCI_INDICSETSTROKEWIDTH = 2751,
        /// <summary>
        /// SCI_INDICGETSTROKEWIDTH(int indicator) -&gt; int<br/>
        /// These two messages set and get the stroke width used to draw an indicator in hundredths of a pixel. The default
        /// value is 100 indicating a width of one pixel. Some indicator styles do not support setting stroke width, generally
        /// where it makes no sense( INDIC_POINT) or wasn't simple( INDIC_SQUIGGLEPIXMAP ). The indicators
        /// supporting stroke width are: INDIC_PLAIN, INDIC_SQUIGGLE, INDIC_TT, INDIC_DIAGONAL ,
        /// INDIC_STRIKE, INDIC_BOX, INDIC_ROUNDBOX, INDIC_STRAIGHTBOX, INDIC_FULLBOX, INDIC_DASH ,
        /// INDIC_DOTS, INDIC_SQUIGGLELOW .
        /// </summary>
        SCI_INDICGETSTROKEWIDTH = 2752,
        /// <summary>
        /// SCI_SETWHITESPACEFORE(bool useSetting, colour fore)<br/>
        /// </summary>
        SCI_SETWHITESPACEFORE = 2084,
        /// <summary>
        /// SCI_SETWHITESPACEBACK(bool useSetting, colour back)<br/>
        /// By default, the colour of visible white space is determined by the lexer in use. The foreground and/or background
        /// colour of all visible white space can be set globally, overriding the lexer's colours with SC_ELEMENT_WHITE_SPACE
        /// and SC_ELEMENT_WHITE_SPACE_BACK. . SCI_SETWHITESPACEFORE and SCI_SETWHITESPACEBACK also change the
        /// white space colours but the element APIs are preferred with SC_ELEMENT_WHITE_SPACE allowing translucency.
        /// </summary>
        SCI_SETWHITESPACEBACK = 2085,
        /// <summary>
        /// SCI_SETWHITESPACESIZE(int size)<br/>
        /// </summary>
        SCI_SETWHITESPACESIZE = 2086,
        /// <summary>
        /// SCI_GETWHITESPACESIZE -&gt; int<br/>
        /// SCI_SETWHITESPACESIZE sets the size of the dots used for mark space characters. The SCI_GETWHITESPACESIZE
        /// message retrieves the current size. The value 0 is valid and makes the dots invisible.
        /// </summary>
        SCI_GETWHITESPACESIZE = 2087,
        /// <summary>
        /// SCI_SETLINESTATE(line line, int state)<br/>
        /// </summary>
        SCI_SETLINESTATE = 2092,
        /// <summary>
        /// SCI_GETLINESTATE(line line) -&gt; int<br/>
        /// As well as the 8 bits of lexical state stored for each character there is also an integer stored for each line.
        /// This can be used for longer lived parse states such as what the current scripting language is in an ASP page. Use
        /// SCI_SETLINESTATE to set the integer value and SCI_GETLINESTATE to get the value. Changing the value
        /// produces a SC_MOD_CHANGELINESTATE notification.
        /// </summary>
        SCI_GETLINESTATE = 2093,
        /// <summary>
        /// SCI_GETMAXLINESTATE -&gt; int<br/>
        /// This returns the last line that has any line state. This has been made less useful by an optimization that always
        /// allocates for all lines if any line's state was set. It can still distinguish cases where line state was never set
        /// for any lines.
        /// </summary>
        SCI_GETMAXLINESTATE = 2094,
        /// <summary>
        /// SCI_GETCARETLINEVISIBLE -&gt; bool<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETCARETLINEVISIBLE = 2095,
        /// <summary>
        /// SCI_SETCARETLINEVISIBLE(bool show)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETCARETLINEVISIBLE = 2096,
        /// <summary>
        /// SCI_GETCARETLINEBACK -&gt; colour<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETCARETLINEBACK = 2097,
        /// <summary>
        /// SCI_SETCARETLINEBACK( colour back)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETCARETLINEBACK = 2098,
        /// <summary>
        /// SCI_GETCARETLINEFRAME -&gt; int<br/>
        /// SCI_SETCARETLINEFRAME can be used to display the caret line framed instead of filling the whole
        /// background. Set width != 0 to enable this option and width= 0 to disable it.
        /// </summary>
        SCI_GETCARETLINEFRAME = 2704,
        /// <summary>
        /// SCI_SETCARETLINEFRAME(int width)<br/>
        /// </summary>
        SCI_SETCARETLINEFRAME = 2705,
        /// <summary>
        /// SCI_STYLESETCHANGEABLE(int style, bool changeable)<br/>
        /// </summary>
        SCI_STYLESETCHANGEABLE = 2099,
        /// <summary>
        /// SCI_AUTOCSHOW(position lengthEntered, const char *itemList)<br/>
        /// This message causes a list to be displayed. lengthEntered is the number of characters of the word already
        /// entered and itemList is the list of words separated by separator characters. The initial separator character is
        /// a space but this can be set or got with SCI_AUTOCSETSEPARATOR and SCI_AUTOCGETSEPARATOR .
        /// </summary>
        SCI_AUTOCSHOW = 2100,
        SCI_AUTOCCANCEL = 2101,
        /// <summary>
        /// SCI_AUTOCACTIVE -&gt; bool<br/>
        /// This message returns non-zero if there is an active autocompletion list and zero if there is not.
        /// </summary>
        SCI_AUTOCACTIVE = 2102,
        /// <summary>
        /// SCI_AUTOCPOSSTART -&gt; position<br/>
        /// This returns the value of the current position when SCI_AUTOCSHOW started display of the list.
        /// </summary>
        SCI_AUTOCPOSSTART = 2103,
        SCI_AUTOCCOMPLETE = 2104,
        /// <summary>
        /// SCI_AUTOCSTOPS(&lt;unused&gt;, const char *characterSet)<br/>
        /// The characterSet argument is a string containing a list of characters that will automatically cancel the
        /// autocompletion list. When you start the editor, this list is empty.
        /// </summary>
        SCI_AUTOCSTOPS = 2105,
        /// <summary>
        /// SCI_AUTOCSETSEPARATOR(int separatorCharacter)<br/>
        /// </summary>
        SCI_AUTOCSETSEPARATOR = 2106,
        /// <summary>
        /// SCI_AUTOCGETSEPARATOR -&gt; int<br/>
        /// These two messages set and get the separator character used to separate words in the SCI_AUTOCSHOW list. The default
        /// is the space character.
        /// </summary>
        SCI_AUTOCGETSEPARATOR = 2107,
        /// <summary>
        /// SCI_AUTOCSELECT(&lt;unused&gt;, const char *select)<br/>
        /// </summary>
        SCI_AUTOCSELECT = 2108,
        /// <summary>
        /// SCI_AUTOCSETCANCELATSTART(bool cancel)<br/>
        /// </summary>
        SCI_AUTOCSETCANCELATSTART = 2110,
        /// <summary>
        /// SCI_AUTOCGETCANCELATSTART -&gt; bool<br/>
        /// The default behaviour is for the list to be cancelled if the caret moves to the location it was at when the list
        /// was displayed. By calling this message with a false argument, the list is not cancelled until the caret moves at
        /// least one character before the word being completed.
        /// </summary>
        SCI_AUTOCGETCANCELATSTART = 2111,
        /// <summary>
        /// SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char *characterSet)<br/>
        /// If a fillup character is typed with an autocompletion list active, the currently selected item in the list is added
        /// into the document, then the fillup character is added. Common fillup characters are '(', '[' and '.' but others are
        /// possible depending on the language. By default, no fillup characters are set.
        /// </summary>
        SCI_AUTOCSETFILLUPS = 2112,
        /// <summary>
        /// SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)<br/>
        /// </summary>
        SCI_AUTOCSETCHOOSESINGLE = 2113,
        /// <summary>
        /// SCI_AUTOCGETCHOOSESINGLE -&gt; bool<br/>
        /// If you use SCI_AUTOCSETCHOOSESINGLE(1) and a list has only one item, it is automatically added and no list is
        /// displayed. The default is to display the list even if there is only a single item.
        /// </summary>
        SCI_AUTOCGETCHOOSESINGLE = 2114,
        /// <summary>
        /// SCI_AUTOCSETIGNORECASE(bool ignoreCase)<br/>
        /// </summary>
        SCI_AUTOCSETIGNORECASE = 2115,
        /// <summary>
        /// SCI_AUTOCGETIGNORECASE -&gt; bool<br/>
        /// By default, matching of characters to list members is case sensitive. These messages let you set and get case
        /// sensitivity.
        /// </summary>
        SCI_AUTOCGETIGNORECASE = 2116,
        /// <summary>
        /// SCI_USERLISTSHOW(int listType, const char *itemList)<br/>
        /// The listType parameter is returned to the container as the wParam field of the SCNotification
        /// structure. It must be greater than 0 as this is how Scintilla tells the difference between an autocompletion list
        /// and a user list. If you have different types of list, for example a list of buffers and a list of macros, you can
        /// use listType to tell which one has returned a selection.
        /// </summary>
        SCI_USERLISTSHOW = 2117,
        /// <summary>
        /// SCI_AUTOCSETAUTOHIDE(bool autoHide)<br/>
        /// </summary>
        SCI_AUTOCSETAUTOHIDE = 2118,
        /// <summary>
        /// SCI_AUTOCGETAUTOHIDE -&gt; bool<br/>
        /// By default, the list is cancelled if there are no viable matches (the user has typed characters that no longer
        /// match a list entry). If you want to keep displaying the original list, set autoHide to false. This also
        /// effects SCI_AUTOCSELECT .
        /// </summary>
        SCI_AUTOCGETAUTOHIDE = 2119,
        SC_AUTOCOMPLETE_NORMAL = 0,
        SC_AUTOCOMPLETE_FIXED_SIZE = 1,
        SC_AUTOCOMPLETE_SELECT_FIRST_ITEM = 2,
        /// <summary>
        /// SCI_AUTOCSETOPTIONS(int options)<br/>
        /// </summary>
        SCI_AUTOCSETOPTIONS = 2638,
        /// <summary>
        /// SCI_AUTOCGETOPTIONS -&gt; int<br/>
        /// Set options for autocompletion from the following list.
        /// </summary>
        SCI_AUTOCGETOPTIONS = 2639,
        /// <summary>
        /// SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)<br/>
        /// </summary>
        SCI_AUTOCSETDROPRESTOFWORD = 2270,
        /// <summary>
        /// SCI_AUTOCGETDROPRESTOFWORD -&gt; bool<br/>
        /// When an item is selected, any word characters following the caret are first erased if dropRestOfWord is set true .
        /// The default is false .
        /// </summary>
        SCI_AUTOCGETDROPRESTOFWORD = 2271,
        /// <summary>
        /// SCI_REGISTERIMAGE(int type, const char *xpmData)<br/>
        /// </summary>
        SCI_REGISTERIMAGE = 2405,
        SCI_CLEARREGISTEREDIMAGES = 2408,
        /// <summary>
        /// SCI_AUTOCGETTYPESEPARATOR -&gt; int<br/>
        /// Autocompletion list items may display an image as well as text. Each image is first registered with an integer
        /// type. Then this integer is included in the text of the list separated by a '?' from the text. For example,
        /// "fclose?2 fopen" displays image 2 before the string "fclose" and no image before "fopen". The images are in
        /// either the XPM format( SCI_REGISTERIMAGE) or RGBA format( SCI_REGISTERRGBAIMAGE ). For
        /// SCI_REGISTERRGBAIMAGE the width and height must previously been set with the SCI_RGBAIMAGESETWIDTH and
        /// SCI_RGBAIMAGESETHEIGHT messages. The set of registered images can be cleared with SCI_CLEARREGISTEREDIMAGES
        /// and the '?' separator changed with SCI_AUTOCSETTYPESEPARATOR .
        /// </summary>
        SCI_AUTOCGETTYPESEPARATOR = 2285,
        /// <summary>
        /// SCI_AUTOCSETTYPESEPARATOR(int separatorCharacter)<br/>
        /// </summary>
        SCI_AUTOCSETTYPESEPARATOR = 2286,
        /// <summary>
        /// SCI_AUTOCSETMAXWIDTH(int characterCount)<br/>
        /// </summary>
        SCI_AUTOCSETMAXWIDTH = 2208,
        /// <summary>
        /// SCI_AUTOCGETMAXWIDTH -&gt; int<br/>
        /// Get or set the maximum width of an autocompletion list expressed as the number of characters in the longest item that
        /// will be totally visible. If zero (the default) then the list's width is calculated to fit the item with the most
        /// characters. Any items that cannot be fully displayed within the available width are indicated by the presence of
        /// ellipsis.
        /// </summary>
        SCI_AUTOCGETMAXWIDTH = 2209,
        /// <summary>
        /// SCI_AUTOCSETMAXHEIGHT(int rowCount)<br/>
        /// </summary>
        SCI_AUTOCSETMAXHEIGHT = 2210,
        /// <summary>
        /// SCI_AUTOCGETMAXHEIGHT -&gt; int<br/>
        /// Get or set the maximum number of rows that will be visible in an autocompletion list. If there are more rows in the
        /// list, then a vertical scrollbar is shown. The default is 5.
        /// </summary>
        SCI_AUTOCGETMAXHEIGHT = 2211,
        /// <summary>
        /// SCI_AUTOCSETSTYLE(int style)<br/>
        /// </summary>
        SCI_AUTOCSETSTYLE = 2109,
        /// <summary>
        /// SCI_AUTOCGETSTYLE -&gt; int<br/>
        /// Get or set the style used by autocompletion lists to determine the font facename, size and character set used to display
        /// characters. Defaults to STYLE_DEFAULT. Always call SCI_ALLOCATEEXTENDEDSTYLES(1) before SCI_AUTOCSETSTYLE
        /// and use the result as the argument to SCI_AUTOCSETSTYLE and SCI_STYLESETFONT and others.
        /// </summary>
        SCI_AUTOCGETSTYLE = 2120,
        /// <summary>
        /// SCI_SETINDENT(int indentSize)<br/>
        /// </summary>
        SCI_SETINDENT = 2122,
        /// <summary>
        /// SCI_GETINDENT -&gt; int<br/>
        /// SCI_SETINDENT sets the size of indentation in terms of the width of a space in STYLE_DEFAULT. If you set a width
        /// of 0, the indent size is the same as the tab size. There are no limits on indent sizes, but values less than 0
        /// or large values may have undesirable effects.
        /// </summary>
        SCI_GETINDENT = 2123,
        /// <summary>
        /// SCI_SETUSETABS(bool useTabs)<br/>
        /// </summary>
        SCI_SETUSETABS = 2124,
        /// <summary>
        /// SCI_GETUSETABS -&gt; bool<br/>
        /// SCI_SETUSETABS determines whether indentation should be created out of a mixture of tabs and spaces or be based
        /// purely on spaces. Set useTabs to false (0) to create all tabs and indents out of spaces. The default is
        /// true. You can use SCI_GETCOLUMN to get the column of a position taking the width of a tab into account.
        /// </summary>
        SCI_GETUSETABS = 2125,
        /// <summary>
        /// SCI_SETLINEINDENTATION(line line, int indentation)<br/>
        /// </summary>
        SCI_SETLINEINDENTATION = 2126,
        /// <summary>
        /// SCI_GETLINEINDENTATION(line line) -&gt; int<br/>
        /// The amount of indentation on a line can be discovered and set with SCI_GETLINEINDENTATION and
        /// SCI_SETLINEINDENTATION. The indentation is measured in character columns, which correspond to the width of space
        /// characters.
        /// </summary>
        SCI_GETLINEINDENTATION = 2127,
        /// <summary>
        /// SCI_GETLINEINDENTPOSITION(line line) -&gt; position<br/>
        /// This returns the position at the end of indentation of a line.
        /// </summary>
        SCI_GETLINEINDENTPOSITION = 2128,
        /// <summary>
        /// SCI_GETCOLUMN(position pos) -&gt; position<br/>
        /// This message returns the column number of a position pos within the document taking the width of tabs into
        /// account. This returns the column number of the last tab on the line before pos, plus the number of characters
        /// between the last tab and pos. If there are no tab characters on the line, the return value is the number of
        /// characters up to the position on the line. In both cases, double byte characters count as a single character. This
        /// is probably only useful with monospaced fonts.
        /// </summary>
        SCI_GETCOLUMN = 2129,
        /// <summary>
        /// SCI_COUNTCHARACTERS(position start, position end) -&gt; position<br/>
        /// Returns the number of whole characters between two positions.
        /// </summary>
        SCI_COUNTCHARACTERS = 2633,
        /// <summary>
        /// SCI_COUNTCODEUNITS(position start, position end) -&gt; position<br/>
        /// These are the UTF-16 versions of SCI_POSITIONRELATIVE and SCI_COUNTCHARACTERS working in terms of UTF-16
        /// code units.
        /// </summary>
        SCI_COUNTCODEUNITS = 2715,
        /// <summary>
        /// SCI_SETHSCROLLBAR(bool visible)<br/>
        /// </summary>
        SCI_SETHSCROLLBAR = 2130,
        /// <summary>
        /// SCI_GETHSCROLLBAR -&gt; bool<br/>
        /// The horizontal scroll bar is only displayed if it is needed for the assumed width. If you never wish to see it,
        /// call SCI_SETHSCROLLBAR(0). Use SCI_SETHSCROLLBAR(1) to enable it again. SCI_GETHSCROLLBAR returns the
        /// current state. The default state is to display it when needed.
        /// </summary>
        SCI_GETHSCROLLBAR = 2131,
        SC_IV_NONE = 0,
        SC_IV_REAL = 1,
        SC_IV_LOOKFORWARD = 2,
        SC_IV_LOOKBOTH = 3,
        /// <summary>
        /// SCI_SETINDENTATIONGUIDES(int indentView)<br/>
        /// </summary>
        SCI_SETINDENTATIONGUIDES = 2132,
        /// <summary>
        /// SCI_GETINDENTATIONGUIDES -&gt; int<br/>
        /// Indentation guides are dotted vertical lines that appear within indentation white space every indent size columns.
        /// They make it easy to see which constructs line up especially when they extend over multiple pages. Style
        /// STYLE_INDENTGUIDE (37) is used to specify the foreground and background colour of the indentation guides.
        /// </summary>
        SCI_GETINDENTATIONGUIDES = 2133,
        /// <summary>
        /// SCI_SETHIGHLIGHTGUIDE(position column)<br/>
        /// </summary>
        SCI_SETHIGHLIGHTGUIDE = 2134,
        /// <summary>
        /// SCI_GETHIGHLIGHTGUIDE -&gt; position<br/>
        /// When brace highlighting occurs, the indentation guide corresponding to the braces may be highlighted with the brace
        /// highlighting style, STYLE_BRACELIGHT (34). Set column to 0 to cancel this highlight.
        /// </summary>
        SCI_GETHIGHLIGHTGUIDE = 2135,
        /// <summary>
        /// SCI_GETLINEENDPOSITION(line line) -&gt; position<br/>
        /// This returns the position at the end of the line, before any line end characters. If line is the last line in
        /// the document (which does not have any end of line characters) or greater, the result is the size of the document.
        /// If line is negative the result is undefined.
        /// </summary>
        SCI_GETLINEENDPOSITION = 2136,
        /// <summary>
        /// SCI_GETCODEPAGE -&gt; int<br/>
        /// Scintilla supports UTF-8, Japanese, Chinese and Korean DBCS along with single byte encodings like Latin-1. UTF-8 (
        /// SC_CP_UTF8) is the default. Use this message with codePage set to the code page number to set Scintilla to
        /// use code page information to ensure multiple byte characters are treated as one character rather than multiple.
        /// This also stops the caret from moving between the bytes in a multi-byte character. Do not use this message to
        /// choose between different single byte character sets- use SCI_STYLESETCHARACTERSET. Call with codePage
        /// set to zero to disable multi-byte support.
        /// </summary>
        SCI_GETCODEPAGE = 2137,
        /// <summary>
        /// SCI_GETCARETFORE -&gt; colour<br/>
        /// The colour of the caret can be set with SCI_SETELEMENTCOLOUR(SC_ELEMENT_CARET) or SCI_SETCARETFORE and
        /// retrieved with SCI_GETELEMENTCOLOUR(SC_ELEMENT_CARET) or SCI_GETCARETFORE. The element APIs
        /// are preferred and allow setting the translucency of carets.
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETCARETFORE = 2138,
        /// <summary>
        /// SCI_GETREADONLY -&gt; bool<br/>
        /// These messages set and get the read-only flag for the document. If you mark a document as read only, attempts to
        /// modify the text cause the SCN_MODIFYATTEMPTRO notification.
        /// </summary>
        SCI_GETREADONLY = 2140,
        /// <summary>
        /// SCI_SETCURRENTPOS(position caret)<br/>
        /// This sets the current position and creates a selection between the anchor and the current position. The caret is
        /// not scrolled into view.
        /// </summary>
        SCI_SETCURRENTPOS = 2141,
        /// <summary>
        /// SCI_SETSELECTIONSTART(position anchor)<br/>
        /// </summary>
        SCI_SETSELECTIONSTART = 2142,
        /// <summary>
        /// SCI_GETSELECTIONSTART -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONSTART = 2143,
        /// <summary>
        /// SCI_SETSELECTIONEND(position caret)<br/>
        /// These set the selection based on the assumption that the anchor position is less than the current position. They do
        /// not make the caret visible. The table shows the positions of the anchor and the current position after using these
        /// messages.
        /// </summary>
        SCI_SETSELECTIONEND = 2144,
        /// <summary>
        /// SCI_GETSELECTIONEND -&gt; position<br/>
        /// These return the start and end of the selection without regard to which end is the current position and which is
        /// the anchor. SCI_GETSELECTIONSTART returns the smaller of the current position or the anchor position.
        /// SCI_GETSELECTIONEND returns the larger of the two values.
        /// </summary>
        SCI_GETSELECTIONEND = 2145,
        /// <summary>
        /// SCI_SETEMPTYSELECTION(position caret)<br/>
        /// This removes any selection and sets the caret at caret. The caret is not scrolled into view.
        /// </summary>
        SCI_SETEMPTYSELECTION = 2556,
        /// <summary>
        /// SCI_SETPRINTMAGNIFICATION(int magnification)<br/>
        /// </summary>
        SCI_SETPRINTMAGNIFICATION = 2146,
        /// <summary>
        /// SCI_GETPRINTMAGNIFICATION -&gt; int<br/>
        /// SCI_GETPRINTMAGNIFICATION lets you to print at a different size than the screen font. magnification is the
        /// number of points to add to the size of each screen font. A value of -3 or -4 gives reasonably small print. You can
        /// get this value with SCI_GETPRINTMAGNIFICATION .
        /// </summary>
        SCI_GETPRINTMAGNIFICATION = 2147,
        SC_PRINT_NORMAL = 0,
        SC_PRINT_INVERTLIGHT = 1,
        SC_PRINT_BLACKONWHITE = 2,
        SC_PRINT_COLOURONWHITE = 3,
        SC_PRINT_COLOURONWHITEDEFAULTBG = 4,
        SC_PRINT_SCREENCOLOURS = 5,
        /// <summary>
        /// SCI_SETPRINTCOLOURMODE(int mode)<br/>
        /// </summary>
        SCI_SETPRINTCOLOURMODE = 2148,
        /// <summary>
        /// SCI_GETPRINTCOLOURMODE -&gt; int<br/>
        /// These two messages set and get the method used to render coloured text on a printer that is probably using white
        /// paper. It is especially important to consider the treatment of colour if you use a dark or black screen background.
        /// Printing white on black uses up toner and ink very many times faster than the other way around. You can set the
        /// mode to one of:
        /// </summary>
        SCI_GETPRINTCOLOURMODE = 2149,
        SCFIND_NONE = 0x0,
        SCFIND_WHOLEWORD = 0x2,
        SCFIND_MATCHCASE = 0x4,
        SCFIND_WORDSTART = 0x00100000,
        SCFIND_REGEXP = 0x00200000,
        SCFIND_POSIX = 0x00400000,
        SCFIND_CXX11REGEX = 0x00800000,
        /// <summary>
        /// SCI_FINDTEXT(int searchFlags, Sci_TextToFind *ft) -&gt; position<br/>
        /// </summary>
        SCI_FINDTEXT = 2150,
        /// <summary>
        /// SCI_FINDTEXTFULL(int searchFlags, Sci_TextToFindFull *ft) -&gt; position<br/>
        /// These messages search for text in the document. They do not use or move the current selection. The searchFlags
        /// argument controls the search type, which includes regular expression searches.
        /// </summary>
        SCI_FINDTEXTFULL = 2196,
        /// <summary>
        /// SCI_FORMATRANGE(bool draw, Sci_RangeToFormat *fr) -&gt; position<br/>
        /// </summary>
        SCI_FORMATRANGE = 2151,
        /// <summary>
        /// SCI_FORMATRANGEFULL(bool draw, Sci_RangeToFormatFull *fr) -&gt; position<br/>
        /// This call renders a range of text into a device context. If you use this for printing, you will probably want to
        /// arrange a page header and footer; Scintilla does not do this for you. See SciTEWin::Print() in SciTEWinDlg.cxx
        /// for an example. Each use of this message renders a range of text into a rectangular area and returns the
        /// position in the document of the next character to print.
        /// </summary>
        SCI_FORMATRANGEFULL = 2777,
        SC_CHANGE_HISTORY_DISABLED = 0,
        SC_CHANGE_HISTORY_ENABLED = 1,
        SC_CHANGE_HISTORY_MARKERS = 2,
        SC_CHANGE_HISTORY_INDICATORS = 4,
        /// <summary>
        /// SCI_SETCHANGEHISTORY(int changeHistory)<br/>
        /// </summary>
        SCI_SETCHANGEHISTORY = 2780,
        /// <summary>
        /// SCI_GETCHANGEHISTORY -&gt; int<br/>
        /// SCI_SETCHANGEHISTORY turns this feature on and off and determines whether changes are visible in the margin or
        /// text or both.
        /// </summary>
        SCI_GETCHANGEHISTORY = 2781,
        /// <summary>
        /// SCI_GETFIRSTVISIBLELINE -&gt; line<br/>
        /// These messages retrieve and set the line number of the first visible line in the Scintilla view. The first line in
        /// the document is numbered 0. The value is a visible line rather than a document line.
        /// </summary>
        SCI_GETFIRSTVISIBLELINE = 2152,
        /// <summary>
        /// SCI_GETLINE(line line, char *text) -&gt; position<br/>
        /// This fills the buffer defined by text with the contents of the nominated line (lines start at 0). The buffer is not
        /// terminated by a NUL(0) character. It is up to you to make sure that the buffer is long enough for the text, use
        /// SCI_LINELENGTH(line line). The returned value is the number of characters copied to the buffer. The returned text
        /// includes any end of line characters. If you ask for a line number outside the range of lines in the document, 0
        /// characters are copied. If the text argument is 0 then the length that should be allocated to store the entire line
        /// is returned.
        /// </summary>
        SCI_GETLINE = 2153,
        /// <summary>
        /// SCI_GETLINECOUNT -&gt; line<br/>
        /// This returns the number of lines in the document. An empty document contains 1 line. A document holding only an end
        /// of line sequence has 2 lines.
        /// </summary>
        SCI_GETLINECOUNT = 2154,
        /// <summary>
        /// SCI_ALLOCATELINES(line lines)<br/>
        /// Allocate line indices to match the lines argument. This is an optimization that can prevent multiple
        /// reallocations of the indices as text is inserted if the application can estimate the number of lines in the
        /// document. The number of lines will not be reduced by this call.
        /// </summary>
        SCI_ALLOCATELINES = 2089,
        /// <summary>
        /// SCI_SETMARGINLEFT(&lt;unused&gt;, int pixelWidth)<br/>
        /// </summary>
        SCI_SETMARGINLEFT = 2155,
        /// <summary>
        /// SCI_GETMARGINLEFT -&gt; int<br/>
        /// </summary>
        SCI_GETMARGINLEFT = 2156,
        /// <summary>
        /// SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixelWidth)<br/>
        /// </summary>
        SCI_SETMARGINRIGHT = 2157,
        /// <summary>
        /// SCI_GETMARGINRIGHT -&gt; int<br/>
        /// These messages set and get the width of the blank margin on both sides of the text in pixels. The default is to one
        /// pixel on each side.
        /// </summary>
        SCI_GETMARGINRIGHT = 2158,
        /// <summary>
        /// SCI_GETMODIFY -&gt; bool<br/>
        /// This returns non-zero if the document is modified and 0 if it is unmodified. The modified status of a document is
        /// determined by the undo position relative to the save point. The save point is set by SCI_SETSAVEPOINT ,
        /// usually when you have saved data to a file.
        /// </summary>
        SCI_GETMODIFY = 2159,
        /// <summary>
        /// SCI_SETSEL(position anchor, position caret)<br/>
        /// This message sets both the anchor and the current position. If caret is negative, it means the end of the
        /// document. If anchor is negative, it means remove any selection (i.e. set the anchor to the same position as
        /// caret ). The caret is scrolled into view after this operation.
        /// </summary>
        SCI_SETSEL = 2160,
        /// <summary>
        /// SCI_GETSELTEXT(&lt;unused&gt;, char *text NUL-terminated) -&gt; position<br/>
        /// This copies the currently selected text and a terminating NUL(0) byte to the text buffer. The buffer size should
        /// be determined by calling with a NULL pointer for the text argument: 1+ SCI_GETSELTEXT(0, NULL). This
        /// allows for rectangular and discontiguous selections as well as simple selections. See Multiple Selection for
        /// information on how multiple and rectangular selections and virtual space are copied.
        /// </summary>
        SCI_GETSELTEXT = 2161,
        /// <summary>
        /// SCI_GETTEXTRANGE(&lt;unused&gt;, Sci_TextRange *tr) -&gt; position<br/>
        /// </summary>
        SCI_GETTEXTRANGE = 2162,
        /// <summary>
        /// SCI_GETTEXTRANGEFULL(&lt;unused&gt;, Sci_TextRangeFull *tr) -&gt; position<br/>
        /// This collects the text between the positions cpMin and cpMax and copies it to lpstrText (see struct
        /// Sci_TextRange in Scintilla.h ). If cpMax is -1, text is returned to the end of the document. The text
        /// is 0 terminated, so you must supply a buffer that is at least 1 character longer than the number of characters you
        /// wish to read. The return value is the length of the returned text not including the terminating 0.
        /// </summary>
        SCI_GETTEXTRANGEFULL = 2039,
        /// <summary>
        /// SCI_HIDESELECTION(bool hide)<br/>
        /// </summary>
        SCI_HIDESELECTION = 2163,
        /// <summary>
        /// SCI_GETSELECTIONHIDDEN -&gt; bool<br/>
        /// The normal state is to make the selection visible by drawing it as set by SCI_SETSELFORE, SCI_SETSELBACK, and
        /// related calls. However, if you hide the selection, it is drawn as normal text.
        /// </summary>
        SCI_GETSELECTIONHIDDEN = 2088,
        /// <summary>
        /// SCI_POINTXFROMPOSITION(&lt;unused&gt;, position pos) -&gt; int<br/>
        /// </summary>
        SCI_POINTXFROMPOSITION = 2164,
        /// <summary>
        /// SCI_POINTYFROMPOSITION(&lt;unused&gt;, position pos) -&gt; int<br/>
        /// These messages return the x and y display pixel location of text at position pos in the document.
        /// </summary>
        SCI_POINTYFROMPOSITION = 2165,
        /// <summary>
        /// SCI_LINEFROMPOSITION(position pos) -&gt; line<br/>
        /// This message returns the line that contains the position pos in the document. The return value is 0 if pos
        /// &lt;= 0. The return value is the last line if pos is beyond the end of the document.
        /// </summary>
        SCI_LINEFROMPOSITION = 2166,
        /// <summary>
        /// SCI_POSITIONFROMLINE(line line) -&gt; position<br/>
        /// This returns the document position that corresponds with the start of the line. If line is negative, the position of
        /// the line holding the start of the selection is returned. If line is greater than the lines in the document, the
        /// return value is -1. If line is equal to the number of lines in the document (i.e. 1 line past the last
        /// line), the return value is the end of the document.
        /// </summary>
        SCI_POSITIONFROMLINE = 2167,
        /// <summary>
        /// SCI_LINESCROLL(position columns, line lines)<br/>
        /// This will attempt to scroll the display by the number of columns and lines that you specify. Positive line values
        /// increase the line number at the top of the screen (i.e. they move the text upwards as far as the user is
        /// concerned), Negative line values do the reverse.
        /// </summary>
        SCI_LINESCROLL = 2168,
        SCI_SCROLLCARET = 2169,
        /// <summary>
        /// SCI_SCROLLRANGE(position secondary, position primary)<br/>
        /// Scroll the argument positions and the range between them into view giving priority to the primary position then
        /// the secondary position. The behaviour is similar to SCI_SCROLLCARET with the primary position used
        /// instead of the caret. An effort is then made to ensure that the secondary position and range between are also
        /// visible. This may be used to make a search match visible.
        /// </summary>
        SCI_SCROLLRANGE = 2569,
        /// <summary>
        /// SCI_REPLACESEL(&lt;unused&gt;, const char *text)<br/>
        /// The currently selected text between the anchor and the current position is replaced by the 0 terminated text
        /// string. If the anchor and current position are the same, the text is inserted at the caret position. The caret is
        /// positioned after the inserted text and the caret is scrolled into view.
        /// </summary>
        SCI_REPLACESEL = 2170,
        /// <summary>
        /// SCI_SETREADONLY(bool readOnly)<br/>
        /// </summary>
        SCI_SETREADONLY = 2171,
        SCI_NULL = 2172,
        /// <summary>
        /// SCI_CANPASTE -&gt; bool<br/>
        /// </summary>
        SCI_CANPASTE = 2173,
        /// <summary>
        /// SCI_CANUNDO -&gt; bool<br/>
        /// SCI_UNDO undoes one action, or if the undo buffer has reached a SCI_ENDUNDOACTION point, all the actions back
        /// to the corresponding SCI_BEGINUNDOACTION .
        /// </summary>
        SCI_CANUNDO = 2174,
        SCI_EMPTYUNDOBUFFER = 2175,
        SCI_UNDO = 2176,
        SCI_CUT = 2177,
        SCI_COPY = 2178,
        SCI_PASTE = 2179,
        SCI_CLEAR = 2180,
        /// <summary>
        /// SCI_SETTEXT(&lt;unused&gt;, const char *text)<br/>
        /// This replaces all the text in the document with the zero terminated text string you pass in.
        /// </summary>
        SCI_SETTEXT = 2181,
        /// <summary>
        /// SCI_GETTEXT(position length, char *text NUL-terminated) -&gt; position<br/>
        /// This returns at most length characters of text from the start of the document plus one terminating 0 character.
        /// When length is beyond document length, it returns document length. To collect all the text in a document, use
        /// SCI_GETLENGTH to get the number of characters in the document( nLen ), allocate a character buffer of
        /// length nLen+1 bytes, then call SCI_GETTEXT(nLen, char *text). If the text argument is NULL(0) then the
        /// length that should be allocated to store the entire document is returned. If you then save the text, you
        /// should use SCI_SETSAVEPOINT to mark the text as unmodified.
        /// </summary>
        SCI_GETTEXT = 2182,
        /// <summary>
        /// SCI_GETTEXTLENGTH -&gt; position<br/>
        /// </summary>
        SCI_GETTEXTLENGTH = 2183,
        /// <summary>
        /// SCI_GETDIRECTFUNCTION -&gt; pointer<br/>
        /// This message returns the address of the function to call to handle Scintilla messages without the overhead of
        /// passing through the Windows messaging system. You need only call this once, regardless of the number of Scintilla
        /// windows you create.
        /// </summary>
        SCI_GETDIRECTFUNCTION = 2184,
        /// <summary>
        /// SCI_GETDIRECTSTATUSFUNCTION -&gt; pointer<br/>
        /// This is similar to SCI_GETDIRECTFUNCTION but the returned function is of type SciFnDirectStatus which also
        /// returns the status to the caller through a pointer to an int. This saves performing an extra call to
        /// retrieve the status in many situations so can be faster.
        /// </summary>
        SCI_GETDIRECTSTATUSFUNCTION = 2772,
        /// <summary>
        /// SCI_GETDIRECTPOINTER -&gt; pointer<br/>
        /// This returns a pointer to data that identifies which Scintilla window is in use. You must call this once for each
        /// Scintilla window you create. When you call the direct function, you must pass in the direct pointer associated with
        /// the target window.
        /// </summary>
        SCI_GETDIRECTPOINTER = 2185,
        /// <summary>
        /// SCI_SETOVERTYPE(bool overType)<br/>
        /// </summary>
        SCI_SETOVERTYPE = 2186,
        /// <summary>
        /// SCI_GETOVERTYPE -&gt; bool<br/>
        /// When overtype is enabled, each typed character replaces the character to the right of the text caret. When overtype
        /// is disabled, characters are inserted at the caret. SCI_GETOVERTYPE returns true (1) if overtyping is active,
        /// otherwise false (0) will be returned. Use SCI_SETOVERTYPE to set the overtype mode.
        /// </summary>
        SCI_GETOVERTYPE = 2187,
        /// <summary>
        /// SCI_SETCARETWIDTH(int pixelWidth)<br/>
        /// </summary>
        SCI_SETCARETWIDTH = 2188,
        /// <summary>
        /// SCI_GETCARETWIDTH -&gt; int<br/>
        /// The width of the line caret can be set with SCI_SETCARETWIDTH to a value of between 0 and 20 pixels. The default
        /// width is 1 pixel. You can read back the current width with SCI_GETCARETWIDTH. A width of 0 makes the caret
        /// invisible, similar to setting the caret style to CARETSTYLE_INVISIBLE (though not interchangeable). This
        /// setting only affects the width of the cursor when the cursor style is set to line caret mode, it does not affect
        /// the width for a block caret.
        /// </summary>
        SCI_GETCARETWIDTH = 2189,
        /// <summary>
        /// SCI_SETTARGETSTART(position start)<br/>
        /// </summary>
        SCI_SETTARGETSTART = 2190,
        /// <summary>
        /// SCI_GETTARGETSTART -&gt; position<br/>
        /// </summary>
        SCI_GETTARGETSTART = 2191,
        /// <summary>
        /// SCI_SETTARGETSTARTVIRTUALSPACE(position space)<br/>
        /// </summary>
        SCI_SETTARGETSTARTVIRTUALSPACE = 2728,
        /// <summary>
        /// SCI_GETTARGETSTARTVIRTUALSPACE -&gt; position<br/>
        /// </summary>
        SCI_GETTARGETSTARTVIRTUALSPACE = 2729,
        /// <summary>
        /// SCI_SETTARGETEND(position end)<br/>
        /// </summary>
        SCI_SETTARGETEND = 2192,
        /// <summary>
        /// SCI_GETTARGETEND -&gt; position<br/>
        /// </summary>
        SCI_GETTARGETEND = 2193,
        /// <summary>
        /// SCI_SETTARGETENDVIRTUALSPACE(position space)<br/>
        /// </summary>
        SCI_SETTARGETENDVIRTUALSPACE = 2730,
        /// <summary>
        /// SCI_GETTARGETENDVIRTUALSPACE -&gt; position<br/>
        /// </summary>
        SCI_GETTARGETENDVIRTUALSPACE = 2731,
        /// <summary>
        /// SCI_SETTARGETRANGE(position start, position end)<br/>
        /// These functions set and return the start and end of the target. When searching you can set start greater than end
        /// to find the last matching text in the target rather than the first matching text. Setting a target position
        /// with SCI_SETTARGETSTART, SCI_SETTARGETEND, or SCI_SETTARGETRANGE sets the virtual space to 0. The
        /// target is also set by a successful SCI_SEARCHINTARGET .
        /// </summary>
        SCI_SETTARGETRANGE = 2686,
        /// <summary>
        /// SCI_GETTARGETTEXT(&lt;unused&gt;, char *text) -&gt; position<br/>
        /// Retrieve the value in the target.
        /// </summary>
        SCI_GETTARGETTEXT = 2687,
        SCI_TARGETFROMSELECTION = 2287,
        SCI_TARGETWHOLEDOCUMENT = 2690,
        /// <summary>
        /// SCI_REPLACETARGET(position length, const char *text) -&gt; position<br/>
        /// If length is -1, text is a zero terminated string, otherwise length sets the number of character to
        /// replace the target with. After replacement, the target range refers to the replacement text. The return value
        /// is the length of the replacement string. Note that the recommended way to delete text in the document is to set the
        /// target to the text to be removed, and to perform a replace target with an empty string.
        /// </summary>
        SCI_REPLACETARGET = 2194,
        /// <summary>
        /// SCI_REPLACETARGETRE(position length, const char *text) -&gt; position<br/>
        /// This replaces the target using regular expressions. If length is -1, text is a zero terminated string,
        /// otherwise length is the number of characters to use. The replacement string is formed from the text string with
        /// any sequences of \1 through \9 replaced by tagged matches from the most recent regular expression
        /// search. \0 is replaced with all the matched text from the most recent search. After replacement, the target
        /// range refers to the replacement text. The return value is the length of the replacement string.
        /// </summary>
        SCI_REPLACETARGETRE = 2195,
        /// <summary>
        /// SCI_REPLACETARGETMINIMAL(position length, const char *text) -&gt; position<br/>
        /// This is similar to SCI_REPLACETARGET but tries to minimize change history when the current target text shares a
        /// common prefix or suffix with the replacement. Only the text that is actually different is marked as changed.
        /// This might be used when automatically reformatting some text so that the whole area formatted doesn't show change
        /// marks. If length is -1, text is a zero terminated string, otherwise length sets the number of
        /// character to replace the target with. After replacement, the target range refers to the replacement text. The
        /// return value is the length of the replacement string. Note that the recommended way to delete text in the document is
        /// to set the target to the text to be removed, and to perform a replace target with an empty string.
        /// </summary>
        SCI_REPLACETARGETMINIMAL = 2779,
        /// <summary>
        /// SCI_SEARCHINTARGET(position length, const char *text) -&gt; position<br/>
        /// This searches for the first occurrence of a text string in the target defined by SCI_SETTARGETSTART and
        /// SCI_SETTARGETEND. The text string is not zero terminated; the size is set by length. The search is modified
        /// by the search flags set by SCI_SETSEARCHFLAGS. If the search succeeds, the target is set to the found text
        /// and the return value is the position of the start of the matching text. If the search fails, the result is -1.
        /// </summary>
        SCI_SEARCHINTARGET = 2197,
        /// <summary>
        /// SCI_SETSEARCHFLAGS(int searchFlags)<br/>
        /// </summary>
        SCI_SETSEARCHFLAGS = 2198,
        /// <summary>
        /// SCI_GETSEARCHFLAGS -&gt; int<br/>
        /// These get and set the searchFlags used by SCI_SEARCHINTARGET. There are several option flags including a
        /// simple regular expression search.
        /// </summary>
        SCI_GETSEARCHFLAGS = 2199,
        /// <summary>
        /// SCI_CALLTIPSHOW(position pos, const char *definition)<br/>
        /// This message starts the process by displaying the call tip window. If a call tip is already active, this has no
        /// effect. pos is the position in the document at which to align the call tip. The call tip text is aligned to
        /// start 1 line below this character unless you have included up and/or down arrows in the call tip text in which case
        /// the tip is aligned to the right-hand edge of the rightmost arrow. The assumption is that you will start the text
        /// with something like "\001 1 of 3 \002". definition is the call tip text. This can contain multiple lines
        /// separated by '\n' (Line Feed, ASCII code 10) characters. Do not include '\r' (Carriage Return, ASCII code
        /// 13), as this will most likely print as an empty box. '\t' (Tab, ASCII code 9) is supported if you set a tabsize
        /// with SCI_CALLTIPUSESTYLE. The position of the caret is remembered here so that the call tip can be cancelled
        /// automatically if subsequent deletion moves the caret before this position.
        /// </summary>
        SCI_CALLTIPSHOW = 2200,
        SCI_CALLTIPCANCEL = 2201,
        /// <summary>
        /// SCI_CALLTIPACTIVE -&gt; bool<br/>
        /// This returns 1 if a call tip is active and 0 if it is not active.
        /// </summary>
        SCI_CALLTIPACTIVE = 2202,
        /// <summary>
        /// SCI_CALLTIPPOSSTART -&gt; position<br/>
        /// </summary>
        SCI_CALLTIPPOSSTART = 2203,
        /// <summary>
        /// SCI_CALLTIPSETPOSSTART(position posStart)<br/>
        /// This message returns or sets the value of the current position when SCI_CALLTIPSHOW started to display the tip.
        /// </summary>
        SCI_CALLTIPSETPOSSTART = 2214,
        /// <summary>
        /// SCI_CALLTIPSETHLT(position highlightStart, position highlightEnd)<br/>
        /// This sets the region of the call tips text to display in a highlighted style. highlightStart is the zero-based index
        /// into the string of the first character to highlight and highlightEnd is the index of the first character after
        /// the highlight. highlightEnd must be greater than highlightStart; highlightEnd-highlightStart is
        /// the number of characters to highlight. Highlights can extend over line ends if this is required.
        /// </summary>
        SCI_CALLTIPSETHLT = 2204,
        /// <summary>
        /// SCI_CALLTIPSETBACK( colour back)<br/>
        /// The background colour of call tips can be set with this message; the default colour is white. It is not a good idea
        /// to set a dark colour as the background as the default colour for normal calltip text is mid grey and the default
        /// colour for highlighted text is dark blue. This also sets the background colour of STYLE_CALLTIP .
        /// </summary>
        SCI_CALLTIPSETBACK = 2205,
        /// <summary>
        /// SCI_CALLTIPSETFORE( colour fore)<br/>
        /// The colour of call tip text can be set with this message; the default colour is mid grey. This also sets the
        /// foreground colour of STYLE_CALLTIP .
        /// </summary>
        SCI_CALLTIPSETFORE = 2206,
        /// <summary>
        /// SCI_CALLTIPSETFOREHLT( colour fore)<br/>
        /// The colour of highlighted call tip text can be set with this message; the default colour is dark blue.
        /// </summary>
        SCI_CALLTIPSETFOREHLT = 2207,
        /// <summary>
        /// SCI_CALLTIPUSESTYLE(int tabSize)<br/>
        /// This message changes the style used for call tips from STYLE_DEFAULT to STYLE_CALLTIP and sets a tab size in
        /// screen pixels. If tabsize is less than 1, Tab characters are not treated specially. Once this call has been
        /// used, the call tip foreground and background colours are also taken from the style.
        /// </summary>
        SCI_CALLTIPUSESTYLE = 2212,
        /// <summary>
        /// SCI_CALLTIPSETPOSITION(bool above)<br/>
        /// By default the calltip is displayed below the text, setting above to true (1) will display it above the text.
        /// </summary>
        SCI_CALLTIPSETPOSITION = 2213,
        /// <summary>
        /// SCI_VISIBLEFROMDOCLINE(line docLine) -&gt; line<br/>
        /// When some lines are hidden and/or annotations are displayed, then a particular line in the document may be
        /// displayed at a different position to its document position. If no lines are hidden and there are no annotations,
        /// this message returns docLine. Otherwise, this returns the display line (counting the very first visible line as
        /// 0). The display line of an invisible line is the same as the previous visible line. The display line number of the
        /// first line in the document is 0. If lines are hidden and docLine is outside the range of lines in the document,
        /// the return value is -1. Lines can occupy more than one display line if they wrap.
        /// </summary>
        SCI_VISIBLEFROMDOCLINE = 2220,
        /// <summary>
        /// SCI_DOCLINEFROMVISIBLE(line displayLine) -&gt; line<br/>
        /// When some lines are hidden and/or annotations are displayed, then a particular line in the document may be
        /// displayed at a different position to its document position. This message returns the document line number that
        /// corresponds to a display line (counting the display line of the first line in the document as 0). If displayLine
        /// is less than or equal to 0, the result is 0. If displayLine is greater than or equal to the number of displayed
        /// lines, the result is the number of lines in the document.
        /// </summary>
        SCI_DOCLINEFROMVISIBLE = 2221,
        /// <summary>
        /// SCI_WRAPCOUNT(line docLine) -&gt; line<br/>
        /// Document lines can occupy more than one display line if they wrap and this returns the number of display lines
        /// needed to wrap a document line.
        /// </summary>
        SCI_WRAPCOUNT = 2235,
        SC_FOLDLEVELNONE = 0x0,
        SC_FOLDLEVELBASE = 0x400,
        SC_FOLDLEVELWHITEFLAG = 0x1000,
        SC_FOLDLEVELHEADERFLAG = 0x2000,
        SC_FOLDLEVELNUMBERMASK = 0x0FFF,
        /// <summary>
        /// SCI_SETFOLDLEVEL(line line, int level)<br/>
        /// </summary>
        SCI_SETFOLDLEVEL = 2222,
        /// <summary>
        /// SCI_GETFOLDLEVEL(line line) -&gt; int<br/>
        /// These two messages set and get a 32-bit value that contains the fold level of a line and some flags associated with
        /// folding. The fold level is a number in the range 0 to SC_FOLDLEVELNUMBERMASK (0x0FFF). However, the initial fold
        /// level is set to SC_FOLDLEVELBASE (0x400) to allow unsigned arithmetic on folding levels. There are two
        /// addition flag bits. SC_FOLDLEVELWHITEFLAG indicates that the line is blank and allows it to be treated slightly
        /// different then its level may indicate. For example, blank lines should generally not be fold points and will be
        /// considered part of the preceding section even though they may have a lesser fold level.
        /// SC_FOLDLEVELHEADERFLAG indicates that the line is a header (fold point). SC_FOLDLEVELNONE is a default level
        /// that may occur before folding.
        /// </summary>
        SCI_GETFOLDLEVEL = 2223,
        /// <summary>
        /// SCI_GETLASTCHILD(line line, int level) -&gt; line<br/>
        /// This message searches for the next line after line, that has a folding level that is less than or equal to
        /// level and then returns the previous line number. If you set level to -1, level is set to the folding
        /// level of line line. If from is a fold point, SCI_GETLASTCHILD(from, -1) returns the last line that
        /// would be in made visible or hidden by toggling the fold state.
        /// </summary>
        SCI_GETLASTCHILD = 2224,
        /// <summary>
        /// SCI_GETFOLDPARENT(line line) -&gt; line<br/>
        /// This message returns the line number of the first line before line that is marked as a fold point with
        /// SC_FOLDLEVELHEADERFLAG and has a fold level less than the line. If no line is found, or if the header flags
        /// and fold levels are inconsistent, the return value is -1.
        /// </summary>
        SCI_GETFOLDPARENT = 2225,
        /// <summary>
        /// SCI_SHOWLINES(line lineStart, line lineEnd)<br/>
        /// </summary>
        SCI_SHOWLINES = 2226,
        /// <summary>
        /// SCI_HIDELINES(line lineStart, line lineEnd)<br/>
        /// </summary>
        SCI_HIDELINES = 2227,
        /// <summary>
        /// SCI_GETLINEVISIBLE(line line) -&gt; bool<br/>
        /// </summary>
        SCI_GETLINEVISIBLE = 2228,
        /// <summary>
        /// SCI_GETALLLINESVISIBLE -&gt; bool<br/>
        /// The first two messages mark a range of lines as visible or invisible and then redraw the display. If
        /// SC_ELEMENT_HIDDEN_LINE is set then a horizontal line is drawn in that colour to indicate that there are hidden
        /// lines. A fold line drawn in that position overrides the hidden line indicator. SCI_GETLINEVISIBLE reports
        /// on the visible state of a line and returns 1 if it is visible and 0 if it is not visible.
        /// SCI_GETALLLINESVISIBLE returns 1 if all lines are visible and 0 if some lines are hidden. These messages
        /// have no effect on fold levels or fold flags.
        /// </summary>
        SCI_GETALLLINESVISIBLE = 2236,
        /// <summary>
        /// SCI_SETFOLDEXPANDED(line line, bool expanded)<br/>
        /// </summary>
        SCI_SETFOLDEXPANDED = 2229,
        /// <summary>
        /// SCI_GETFOLDEXPANDED(line line) -&gt; bool<br/>
        /// These messages set and get the expanded state of a single line. The set message has no effect on the visible state
        /// of the line or any lines that depend on it. It does change the markers in the folding margin. If you ask for the
        /// expansion state of a line that is outside the document, the result is false (0).
        /// </summary>
        SCI_GETFOLDEXPANDED = 2230,
        /// <summary>
        /// SCI_TOGGLEFOLD(line line)<br/>
        /// </summary>
        SCI_TOGGLEFOLD = 2231,
        /// <summary>
        /// SCI_TOGGLEFOLDSHOWTEXT(line line, const char *text)<br/>
        /// Each fold point may be either expanded, displaying all its child lines, or contracted, hiding all the child lines.
        /// These messages toggle the folding state of the given line as long as it has the SC_FOLDLEVELHEADERFLAG set.
        /// These messages take care of folding or expanding all the lines that depend on the line. The display updates after
        /// this message.
        /// </summary>
        SCI_TOGGLEFOLDSHOWTEXT = 2700,
        SC_FOLDDISPLAYTEXT_HIDDEN = 0,
        SC_FOLDDISPLAYTEXT_STANDARD = 1,
        SC_FOLDDISPLAYTEXT_BOXED = 2,
        /// <summary>
        /// SCI_FOLDDISPLAYTEXTSETSTYLE(int style)<br/>
        /// </summary>
        SCI_FOLDDISPLAYTEXTSETSTYLE = 2701,
        /// <summary>
        /// SCI_FOLDDISPLAYTEXTGETSTYLE -&gt; int<br/>
        /// These message changes the appearance of fold text tags.
        /// </summary>
        SCI_FOLDDISPLAYTEXTGETSTYLE = 2707,
        /// <summary>
        /// SCI_SETDEFAULTFOLDDISPLAYTEXT(&lt;unused&gt;, const char *text)<br/>
        /// </summary>
        SCI_SETDEFAULTFOLDDISPLAYTEXT = 2722,
        /// <summary>
        /// SCI_GETDEFAULTFOLDDISPLAYTEXT(&lt;unused&gt;, char *text) -&gt; int<br/>
        /// These messages set and get the default text displayed at the right of the folded text.
        /// </summary>
        SCI_GETDEFAULTFOLDDISPLAYTEXT = 2723,
        SC_FOLDACTION_CONTRACT = 0,
        SC_FOLDACTION_EXPAND = 1,
        SC_FOLDACTION_TOGGLE = 2,
        SC_FOLDACTION_CONTRACT_EVERY_LEVEL = 4,
        /// <summary>
        /// SCI_FOLDLINE(line line, int action)<br/>
        /// </summary>
        SCI_FOLDLINE = 2237,
        /// <summary>
        /// SCI_FOLDCHILDREN(line line, int action)<br/>
        /// </summary>
        SCI_FOLDCHILDREN = 2238,
        /// <summary>
        /// SCI_EXPANDCHILDREN(line line, int level)<br/>
        /// This is used to respond to a change to a line causing its fold level or whether it is a header to change, perhaps
        /// when adding or removing a '{'.
        /// </summary>
        SCI_EXPANDCHILDREN = 2239,
        /// <summary>
        /// SCI_FOLDALL(int action)<br/>
        /// These messages provide a higher-level approach to folding instead of setting expanded flags and showing or hiding
        /// individual lines.
        /// </summary>
        SCI_FOLDALL = 2662,
        /// <summary>
        /// SCI_ENSUREVISIBLE(line line)<br/>
        /// </summary>
        SCI_ENSUREVISIBLE = 2232,
        SC_AUTOMATICFOLD_NONE = 0x0000,
        SC_AUTOMATICFOLD_SHOW = 0x0001,
        SC_AUTOMATICFOLD_CLICK = 0x0002,
        SC_AUTOMATICFOLD_CHANGE = 0x0004,
        /// <summary>
        /// SCI_SETAUTOMATICFOLD(int automaticFold)<br/>
        /// </summary>
        SCI_SETAUTOMATICFOLD = 2663,
        /// <summary>
        /// SCI_GETAUTOMATICFOLD -&gt; int<br/>
        /// Instead of implementing all the logic for handling folding in the container, Scintilla can provide behaviour that
        /// is adequate for many applications. The automaticFold argument is a bit set defining which of the 3 pieces of
        /// folding implementation should be enabled. Most applications should be able to use the SC_AUTOMATICFOLD_SHOW and
        /// SC_AUTOMATICFOLD_CHANGE flags unless they wish to implement quite different behaviour such as defining their own
        /// fold structure. SC_AUTOMATICFOLD_CLICK is more likely to be set off when an application would like to add
        /// or change click behaviour such as showing method headers only when Shift+Alt is used in conjunction with a click.
        /// </summary>
        SCI_GETAUTOMATICFOLD = 2664,
        SC_FOLDFLAG_NONE = 0x0000,
        SC_FOLDFLAG_LINEBEFORE_EXPANDED = 0x0002,
        SC_FOLDFLAG_LINEBEFORE_CONTRACTED = 0x0004,
        SC_FOLDFLAG_LINEAFTER_EXPANDED = 0x0008,
        SC_FOLDFLAG_LINEAFTER_CONTRACTED = 0x0010,
        SC_FOLDFLAG_LEVELNUMBERS = 0x0040,
        SC_FOLDFLAG_LINESTATE = 0x0080,
        /// <summary>
        /// SCI_SETFOLDFLAGS(int flags)<br/>
        /// </summary>
        SCI_SETFOLDFLAGS = 2233,
        /// <summary>
        /// SCI_ENSUREVISIBLEENFORCEPOLICY(line line)<br/>
        /// A line may be hidden because more than one of its parent lines is contracted. Both these message travels up the
        /// fold hierarchy, expanding any contracted folds until they reach the top level. The line will then be visible. If
        /// you use SCI_ENSUREVISIBLEENFORCEPOLICY, the vertical caret policy set by SCI_SETVISIBLEPOLICY is then
        /// applied.
        /// </summary>
        SCI_ENSUREVISIBLEENFORCEPOLICY = 2234,
        /// <summary>
        /// SCI_SETTABINDENTS(bool tabIndents)<br/>
        /// </summary>
        SCI_SETTABINDENTS = 2260,
        /// <summary>
        /// SCI_GETTABINDENTS -&gt; bool<br/>
        /// </summary>
        SCI_GETTABINDENTS = 2261,
        /// <summary>
        /// SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)<br/>
        /// </summary>
        SCI_SETBACKSPACEUNINDENTS = 2262,
        /// <summary>
        /// SCI_GETBACKSPACEUNINDENTS -&gt; bool<br/>
        /// </summary>
        SCI_GETBACKSPACEUNINDENTS = 2263,
        SC_TIME_FOREVER = 10000000,
        /// <summary>
        /// SCI_SETMOUSEDWELLTIME(int periodMilliseconds)<br/>
        /// </summary>
        SCI_SETMOUSEDWELLTIME = 2264,
        /// <summary>
        /// SCI_GETMOUSEDWELLTIME -&gt; int<br/>
        /// These two messages set and get the time the mouse must sit still, in milliseconds, to generate a SCN_DWELLSTART
        /// notification. If set to SC_TIME_FOREVER, the default, no dwell events are generated.
        /// </summary>
        SCI_GETMOUSEDWELLTIME = 2265,
        /// <summary>
        /// SCI_WORDSTARTPOSITION(position pos, bool onlyWordCharacters) -&gt; position<br/>
        /// These messages return the start and end of words using the same definition of words as used internally within
        /// Scintilla. You can set your own list of characters that count as words with SCI_SETWORDCHARS. The position sets
        /// the start or the search, which is forwards when searching for the end and backwards when searching for the start.
        /// </summary>
        SCI_WORDSTARTPOSITION = 2266,
        /// <summary>
        /// SCI_WORDENDPOSITION(position pos, bool onlyWordCharacters) -&gt; position<br/>
        /// </summary>
        SCI_WORDENDPOSITION = 2267,
        /// <summary>
        /// SCI_ISRANGEWORD(position start, position end) -&gt; bool<br/>
        /// Is the range start..end a word or set of words? This message checks that start is at a word start transition and that
        /// end is at a word end transition. It does not check whether there are any spaces inside the range.
        /// </summary>
        SCI_ISRANGEWORD = 2691,
        SC_IDLESTYLING_NONE = 0,
        SC_IDLESTYLING_TOVISIBLE = 1,
        SC_IDLESTYLING_AFTERVISIBLE = 2,
        SC_IDLESTYLING_ALL = 3,
        /// <summary>
        /// SCI_SETIDLESTYLING(int idleStyling)<br/>
        /// </summary>
        SCI_SETIDLESTYLING = 2692,
        /// <summary>
        /// SCI_GETIDLESTYLING -&gt; int<br/>
        /// By default, SC_IDLESTYLING_NONE (0), syntax styling is performed for all the currently visible text before
        /// displaying it. On very large files, this may make scrolling down slow. With SC_IDLESTYLING_TOVISIBLE
        /// (1), a small amount of styling is performed before display and then further styling is performed
        /// incrementally in the background as an idle-time task. This may result in the text initially appearing uncoloured
        /// and then, some time later, it is coloured. Text after the currently visible portion may be styled in the
        /// background with SC_IDLESTYLING_AFTERVISIBLE (2). To style both before and after the visible text in the
        /// background use SC_IDLESTYLING_ALL (3).
        /// </summary>
        SCI_GETIDLESTYLING = 2693,
        SC_WRAP_NONE = 0,
        SC_WRAP_WORD = 1,
        SC_WRAP_CHAR = 2,
        SC_WRAP_WHITESPACE = 3,
        /// <summary>
        /// SCI_SETWRAPMODE(int wrapMode)<br/>
        /// </summary>
        SCI_SETWRAPMODE = 2268,
        /// <summary>
        /// SCI_GETWRAPMODE -&gt; int<br/>
        /// Set wrapMode to SC_WRAP_WORD (1) to enable wrapping on word or style boundaries, SC_WRAP_CHAR (2) to enable
        /// wrapping between any characters, SC_WRAP_WHITESPACE (3) to enable wrapping on whitespace, and
        /// SC_WRAP_NONE (0) to disable line wrapping. SC_WRAP_CHAR is preferred for Asian languages where there
        /// is no white space between words.
        /// </summary>
        SCI_GETWRAPMODE = 2269,
        SC_WRAPVISUALFLAG_NONE = 0x0000,
        SC_WRAPVISUALFLAG_END = 0x0001,
        SC_WRAPVISUALFLAG_START = 0x0002,
        SC_WRAPVISUALFLAG_MARGIN = 0x0004,
        /// <summary>
        /// SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)<br/>
        /// </summary>
        SCI_SETWRAPVISUALFLAGS = 2460,
        /// <summary>
        /// SCI_GETWRAPVISUALFLAGS -&gt; int<br/>
        /// You can enable the drawing of visual flags to indicate a line is wrapped. Bits set in wrapVisualFlags
        /// determine which visual flags are drawn.
        /// </summary>
        SCI_GETWRAPVISUALFLAGS = 2461,
        SC_WRAPVISUALFLAGLOC_DEFAULT = 0x0000,
        SC_WRAPVISUALFLAGLOC_END_BY_TEXT = 0x0001,
        SC_WRAPVISUALFLAGLOC_START_BY_TEXT = 0x0002,
        /// <summary>
        /// SCI_SETWRAPVISUALFLAGSLOCATION(int wrapVisualFlagsLocation)<br/>
        /// </summary>
        SCI_SETWRAPVISUALFLAGSLOCATION = 2462,
        /// <summary>
        /// SCI_GETWRAPVISUALFLAGSLOCATION -&gt; int<br/>
        /// You can set whether the visual flags to indicate a line is wrapped are drawn near the border or near the text.
        /// Bits set in wrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.
        /// </summary>
        SCI_GETWRAPVISUALFLAGSLOCATION = 2463,
        /// <summary>
        /// SCI_SETWRAPSTARTINDENT(int indent)<br/>
        /// </summary>
        SCI_SETWRAPSTARTINDENT = 2464,
        /// <summary>
        /// SCI_GETWRAPSTARTINDENT -&gt; int<br/>
        /// SCI_SETWRAPSTARTINDENT sets the size of indentation of sublines for wrapped lines in terms of the
        /// average character width in STYLE_DEFAULT. There are no limits on indent sizes, but
        /// values less than 0 or large values may have undesirable effects. The indention of sublines is
        /// independent of visual flags, but if SC_WRAPVISUALFLAG_START is set an indent of at least 1 is used.
        /// </summary>
        SCI_GETWRAPSTARTINDENT = 2465,
        SC_WRAPINDENT_FIXED = 0,
        SC_WRAPINDENT_SAME = 1,
        SC_WRAPINDENT_INDENT = 2,
        SC_WRAPINDENT_DEEPINDENT = 3,
        /// <summary>
        /// SCI_SETWRAPINDENTMODE(int wrapIndentMode)<br/>
        /// </summary>
        SCI_SETWRAPINDENTMODE = 2472,
        /// <summary>
        /// SCI_GETWRAPINDENTMODE -&gt; int<br/>
        /// Wrapped sublines can be indented to the position of their first subline or one more indent level. The default
        /// is SC_WRAPINDENT_FIXED. The modes are:
        /// </summary>
        SCI_GETWRAPINDENTMODE = 2473,
        SC_CACHE_NONE = 0,
        SC_CACHE_CARET = 1,
        SC_CACHE_PAGE = 2,
        SC_CACHE_DOCUMENT = 3,
        /// <summary>
        /// SCI_SETLAYOUTCACHE(int cacheMode)<br/>
        /// </summary>
        SCI_SETLAYOUTCACHE = 2272,
        /// <summary>
        /// SCI_GETLAYOUTCACHE -&gt; int<br/>
        /// You can set cacheMode to one of the symbols in the table:
        /// </summary>
        SCI_GETLAYOUTCACHE = 2273,
        /// <summary>
        /// SCI_SETSCROLLWIDTH(int pixelWidth)<br/>
        /// </summary>
        SCI_SETSCROLLWIDTH = 2274,
        /// <summary>
        /// SCI_GETSCROLLWIDTH -&gt; int<br/>
        /// For performance, Scintilla does not measure the display width of the document to determine the properties of the
        /// horizontal scroll bar. Instead, an assumed width is used. These messages set and get the document width in pixels
        /// assumed by Scintilla. The default value is 2000. To ensure the width of the currently visible lines can be
        /// scrolled use SCI_SETSCROLLWIDTHTRACKING
        /// </summary>
        SCI_GETSCROLLWIDTH = 2275,
        /// <summary>
        /// SCI_SETSCROLLWIDTHTRACKING(bool tracking)<br/>
        /// </summary>
        SCI_SETSCROLLWIDTHTRACKING = 2516,
        /// <summary>
        /// SCI_GETSCROLLWIDTHTRACKING -&gt; bool<br/>
        /// If scroll width tracking is enabled then the scroll width is adjusted to ensure that all of the lines currently
        /// displayed can be completely scrolled. This mode never adjusts the scroll width to be narrower.
        /// </summary>
        SCI_GETSCROLLWIDTHTRACKING = 2517,
        /// <summary>
        /// SCI_TEXTWIDTH(int style, const char *text) -&gt; int<br/>
        /// This returns the pixel width of a string drawn in the given style which can be used, for example, to decide how
        /// wide to make the line number margin in order to display a given number of numerals.
        /// </summary>
        SCI_TEXTWIDTH = 2276,
        /// <summary>
        /// SCI_SETENDATLASTLINE(bool endAtLastLine)<br/>
        /// </summary>
        SCI_SETENDATLASTLINE = 2277,
        /// <summary>
        /// SCI_GETENDATLASTLINE -&gt; bool<br/>
        /// SCI_SETENDATLASTLINE sets the scroll range so that maximum scroll position has the last line at the bottom of the
        /// view (default). Setting this to false allows scrolling one page below the last line.
        /// </summary>
        SCI_GETENDATLASTLINE = 2278,
        /// <summary>
        /// SCI_TEXTHEIGHT(line line) -&gt; int<br/>
        /// This returns the height in pixels of a particular line. Currently all lines are the same height.
        /// </summary>
        SCI_TEXTHEIGHT = 2279,
        /// <summary>
        /// SCI_SETVSCROLLBAR(bool visible)<br/>
        /// </summary>
        SCI_SETVSCROLLBAR = 2280,
        /// <summary>
        /// SCI_GETVSCROLLBAR -&gt; bool<br/>
        /// By default, the vertical scroll bar is always displayed when required. You can choose to hide or show it with
        /// SCI_SETVSCROLLBAR and get the current state with SCI_GETVSCROLLBAR .
        /// </summary>
        SCI_GETVSCROLLBAR = 2281,
        /// <summary>
        /// SCI_APPENDTEXT(position length, const char *text)<br/>
        /// This adds the first length characters from the string text to the end of the document. This will
        /// include any 0's in the string that you might have expected to stop the operation. The current selection is not
        /// changed and the new text is not scrolled into view.
        /// </summary>
        SCI_APPENDTEXT = 2282,
        SC_PHASES_ONE = 0,
        SC_PHASES_TWO = 1,
        SC_PHASES_MULTIPLE = 2,
        /// <summary>
        /// SCI_GETPHASESDRAW -&gt; int<br/>
        /// There are several orders in which the text area may be drawn offering a trade-off between speed and allowing all
        /// pixels of text to be seen even when they overlap other elements.
        /// </summary>
        SCI_GETPHASESDRAW = 2673,
        /// <summary>
        /// SCI_SETPHASESDRAW(int phases)<br/>
        /// </summary>
        SCI_SETPHASESDRAW = 2674,
        SC_EFF_QUALITY_MASK = 0xF,
        SC_EFF_QUALITY_DEFAULT = 0,
        SC_EFF_QUALITY_NON_ANTIALIASED = 1,
        SC_EFF_QUALITY_ANTIALIASED = 2,
        SC_EFF_QUALITY_LCD_OPTIMIZED = 3,
        /// <summary>
        /// SCI_SETFONTQUALITY(int fontQuality)<br/>
        /// </summary>
        SCI_SETFONTQUALITY = 2611,
        /// <summary>
        /// SCI_GETFONTQUALITY -&gt; int<br/>
        /// Manage font quality (antialiasing method). Currently, the following values are available on Windows:
        /// SC_EFF_QUALITY_DEFAULT (backward compatible), SC_EFF_QUALITY_NON_ANTIALIASED ,
        /// SC_EFF_QUALITY_ANTIALIASED, SC_EFF_QUALITY_LCD_OPTIMIZED .
        /// </summary>
        SCI_GETFONTQUALITY = 2612,
        /// <summary>
        /// SCI_SETFIRSTVISIBLELINE(line displayLine)<br/>
        /// </summary>
        SCI_SETFIRSTVISIBLELINE = 2613,
        SC_MULTIPASTE_ONCE = 0,
        SC_MULTIPASTE_EACH = 1,
        /// <summary>
        /// SCI_SETMULTIPASTE(int multiPaste)<br/>
        /// </summary>
        SCI_SETMULTIPASTE = 2614,
        /// <summary>
        /// SCI_GETMULTIPASTE -&gt; int<br/>
        /// When pasting into multiple selections, the pasted text can go into just the main selection with SC_MULTIPASTE_ONCE =0
        /// or into each selection with SC_MULTIPASTE_EACH =1. SC_MULTIPASTE_ONCE is the default.
        /// </summary>
        SCI_GETMULTIPASTE = 2615,
        /// <summary>
        /// SCI_GETTAG(int tagNumber, char *tagValue NUL-terminated) -&gt; int<br/>
        /// Discover what text was matched by tagged expressions in a regular expression search. This is useful if the
        /// application wants to interpret the replacement string itself.
        /// </summary>
        SCI_GETTAG = 2616,
        SCI_LINESJOIN = 2288,
        /// <summary>
        /// SCI_LINESSPLIT(int pixelWidth)<br/>
        /// Split a range of lines indicated by the target into lines that are at most pixelWidth wide. Splitting occurs on
        /// word boundaries wherever possible in a similar manner to line wrapping. When pixelWidth is 0 then the width of
        /// the window is used.
        /// </summary>
        SCI_LINESSPLIT = 2289,
        /// <summary>
        /// SCI_SETFOLDMARGINCOLOUR(bool useSetting, colour back)<br/>
        /// </summary>
        SCI_SETFOLDMARGINCOLOUR = 2290,
        /// <summary>
        /// SCI_SETFOLDMARGINHICOLOUR(bool useSetting, colour fore)<br/>
        /// These messages allow changing the colour of the fold margin and fold margin highlight. On Windows the fold margin
        /// colour defaults to ::GetSysColor(COLOR_3DFACE) and the fold margin highlight colour to
        /// ::GetSysColor(COLOR_3DHIGHLIGHT).
        /// </summary>
        SCI_SETFOLDMARGINHICOLOUR = 2291,
        SC_ACCESSIBILITY_DISABLED = 0,
        SC_ACCESSIBILITY_ENABLED = 1,
        /// <summary>
        /// SCI_SETACCESSIBILITY(int accessibility)<br/>
        /// </summary>
        SCI_SETACCESSIBILITY = 2702,
        /// <summary>
        /// SCI_GETACCESSIBILITY -&gt; int<br/>
        /// These messages may enable or disable accessibility and report its current status.
        /// </summary>
        SCI_GETACCESSIBILITY = 2703,
        SCI_LINEDOWN = 2300,
        SCI_LINEDOWNEXTEND = 2301,
        SCI_LINEUP = 2302,
        SCI_LINEUPEXTEND = 2303,
        SCI_CHARLEFT = 2304,
        SCI_CHARLEFTEXTEND = 2305,
        SCI_CHARRIGHT = 2306,
        SCI_CHARRIGHTEXTEND = 2307,
        SCI_WORDLEFT = 2308,
        SCI_WORDLEFTEXTEND = 2309,
        SCI_WORDRIGHT = 2310,
        SCI_WORDRIGHTEXTEND = 2311,
        SCI_HOME = 2312,
        SCI_HOMEEXTEND = 2313,
        SCI_LINEEND = 2314,
        SCI_LINEENDEXTEND = 2315,
        SCI_DOCUMENTSTART = 2316,
        SCI_DOCUMENTSTARTEXTEND = 2317,
        SCI_DOCUMENTEND = 2318,
        SCI_DOCUMENTENDEXTEND = 2319,
        SCI_PAGEUP = 2320,
        SCI_PAGEUPEXTEND = 2321,
        SCI_PAGEDOWN = 2322,
        SCI_PAGEDOWNEXTEND = 2323,
        SCI_EDITTOGGLEOVERTYPE = 2324,
        SCI_CANCEL = 2325,
        SCI_DELETEBACK = 2326,
        SCI_TAB = 2327,
        SCI_LINEINDENT = 2813,
        SCI_BACKTAB = 2328,
        SCI_LINEDEDENT = 2814,
        SCI_NEWLINE = 2329,
        SCI_FORMFEED = 2330,
        SCI_VCHOME = 2331,
        SCI_VCHOMEEXTEND = 2332,
        SCI_ZOOMIN = 2333,
        SCI_ZOOMOUT = 2334,
        SCI_DELWORDLEFT = 2335,
        SCI_DELWORDRIGHT = 2336,
        SCI_DELWORDRIGHTEND = 2518,
        SCI_LINECUT = 2337,
        SCI_LINEDELETE = 2338,
        SCI_LINETRANSPOSE = 2339,
        SCI_LINEREVERSE = 2354,
        SCI_LINEDUPLICATE = 2404,
        SCI_LOWERCASE = 2340,
        SCI_UPPERCASE = 2341,
        SCI_LINESCROLLDOWN = 2342,
        SCI_LINESCROLLUP = 2343,
        SCI_DELETEBACKNOTLINE = 2344,
        SCI_HOMEDISPLAY = 2345,
        SCI_HOMEDISPLAYEXTEND = 2346,
        SCI_LINEENDDISPLAY = 2347,
        SCI_LINEENDDISPLAYEXTEND = 2348,
        SCI_HOMEWRAP = 2349,
        SCI_HOMEWRAPEXTEND = 2450,
        SCI_LINEENDWRAP = 2451,
        SCI_LINEENDWRAPEXTEND = 2452,
        SCI_VCHOMEWRAP = 2453,
        SCI_VCHOMEWRAPEXTEND = 2454,
        SCI_LINECOPY = 2455,
        SCI_MOVECARETINSIDEVIEW = 2401,
        /// <summary>
        /// SCI_LINELENGTH(line line) -&gt; position<br/>
        /// This returns the length of the line, including any line end characters. If line is negative or beyond the last
        /// line in the document, the result is 0. If you want the length of the line not including any end of line characters,
        /// use SCI_GETLINEENDPOSITION(line)- SCI_POSITIONFROMLINE(line) .
        /// </summary>
        SCI_LINELENGTH = 2350,
        /// <summary>
        /// SCI_BRACEHIGHLIGHT(position posA, position posB)<br/>
        /// Up to two characters can be highlighted in a 'brace highlighting style', which is defined as style number
        /// STYLE_BRACELIGHT (34). If you have enabled indent guides, you may also wish to highlight the indent that
        /// corresponds with the brace. You can locate the column with SCI_GETCOLUMN and highlight the indent with
        /// SCI_SETHIGHLIGHTGUIDE .
        /// </summary>
        SCI_BRACEHIGHLIGHT = 2351,
        /// <summary>
        /// SCI_BRACEHIGHLIGHTINDICATOR(bool useSetting, int indicator)<br/>
        /// Use specified indicator to highlight matching braces instead of changing their style.
        /// </summary>
        SCI_BRACEHIGHLIGHTINDICATOR = 2498,
        /// <summary>
        /// SCI_BRACEBADLIGHT(position pos)<br/>
        /// If there is no matching brace then the brace badlighting style, style STYLE_BRACEBAD (35), can be used to
        /// show the brace that is unmatched. Using a position of INVALID_POSITION (-1) removes the highlight.
        /// </summary>
        SCI_BRACEBADLIGHT = 2352,
        /// <summary>
        /// SCI_BRACEBADLIGHTINDICATOR(bool useSetting, int indicator)<br/>
        /// Use specified indicator to highlight non matching brace instead of changing its style.
        /// </summary>
        SCI_BRACEBADLIGHTINDICATOR = 2499,
        /// <summary>
        /// SCI_BRACEMATCH(position pos, int maxReStyle) -&gt; position<br/>
        /// The SCI_BRACEMATCH message finds a corresponding matching brace given pos, the position of one brace. The
        /// brace characters handled are '(', ')', '[', ']', '{', '}', '&lt;', and '&gt;'. The search is forwards from an opening
        /// brace and backwards from a closing brace. If the character at position is not a brace character, or a matching
        /// brace cannot be found, the return value is -1. Otherwise, the return value is the position of the matching brace.
        /// </summary>
        SCI_BRACEMATCH = 2353,
        /// <summary>
        /// SCI_BRACEMATCHNEXT(position pos, position startPos) -&gt; position<br/>
        /// Similar to SCI_BRACEMATCH, but matching starts at the explicit start position startPos instead of the
        /// implicitly next position pos± 1 .
        /// </summary>
        SCI_BRACEMATCHNEXT = 2369,
        /// <summary>
        /// SCI_GETVIEWEOL -&gt; bool<br/>
        /// Normally, the end of line characters are hidden, but SCI_SETVIEWEOL allows you to display (or hide) them by
        /// setting visible true (or false ). The visible rendering of the end of line characters is similar to
        /// (CR), (LF), or (CR)(LF). SCI_GETVIEWEOL returns the current state.
        /// </summary>
        SCI_GETVIEWEOL = 2355,
        /// <summary>
        /// SCI_SETVIEWEOL(bool visible)<br/>
        /// </summary>
        SCI_SETVIEWEOL = 2356,
        /// <summary>
        /// SCI_GETDOCPOINTER -&gt; pointer<br/>
        /// This returns a pointer to the document currently in use by the window. It has no other effect.
        /// </summary>
        SCI_GETDOCPOINTER = 2357,
        /// <summary>
        /// SCI_SETDOCPOINTER(&lt;unused&gt;, pointer doc)<br/>
        /// This message does the following: 1. It removes the current window from the list held by the current document. 2. It
        /// reduces the reference count of the current document by 1. 3. If the reference count reaches 0, the document is
        /// deleted. 4. doc is set as the new document for the window. 5. If doc was 0, a new, empty document is created
        /// and attached to the window. 6. If doc was not 0, its reference count is increased by 1.
        /// </summary>
        SCI_SETDOCPOINTER = 2358,
        /// <summary>
        /// SCI_SETMODEVENTMASK(int eventMask)<br/>
        /// </summary>
        SCI_SETMODEVENTMASK = 2359,
        EDGE_NONE = 0,
        EDGE_LINE = 1,
        EDGE_BACKGROUND = 2,
        EDGE_MULTILINE = 3,
        /// <summary>
        /// SCI_GETEDGECOLUMN -&gt; position<br/>
        /// These messages set and get the column number at which to display the long line marker. When drawing lines, the
        /// column sets a position in units of the width of a space character in STYLE_DEFAULT. When setting the background
        /// colour, the column is a character count (allowing for tabs) into the line.
        /// </summary>
        SCI_GETEDGECOLUMN = 2360,
        /// <summary>
        /// SCI_SETEDGECOLUMN(position column)<br/>
        /// </summary>
        SCI_SETEDGECOLUMN = 2361,
        /// <summary>
        /// SCI_GETEDGEMODE -&gt; int<br/>
        /// These two messages set and get the mode used to display long lines. You can set one of the values in the table:
        /// </summary>
        SCI_GETEDGEMODE = 2362,
        /// <summary>
        /// SCI_SETEDGEMODE(int edgeMode)<br/>
        /// </summary>
        SCI_SETEDGEMODE = 2363,
        /// <summary>
        /// SCI_GETEDGECOLOUR -&gt; colour<br/>
        /// These messages set and get the colour of the marker used to show that a line has exceeded the length set by
        /// SCI_SETEDGECOLUMN .
        /// </summary>
        SCI_GETEDGECOLOUR = 2364,
        /// <summary>
        /// SCI_SETEDGECOLOUR( colour edgeColour)<br/>
        /// </summary>
        SCI_SETEDGECOLOUR = 2365,
        /// <summary>
        /// SCI_MULTIEDGEADDLINE(position column, colour edgeColour)<br/>
        /// </summary>
        SCI_MULTIEDGEADDLINE = 2694,
        SCI_MULTIEDGECLEARALL = 2695,
        /// <summary>
        /// SCI_GETMULTIEDGECOLUMN(int which) -&gt; position<br/>
        /// SCI_MULTIEDGEADDLINE adds a new vertical edge to the view. The edge will be displayed at the given column number.
        /// The resulting edge position depends on the metric of a space character in STYLE_DEFAULT. All the edges can be
        /// cleared with SCI_MULTIEDGECLEARALL. SCI_GETMULTIEDGECOLUMN returns the column of the Nth vertical edge
        /// (indexed from 0). If which is greater or equal to the number of vertical edges, this returns -1.
        /// </summary>
        SCI_GETMULTIEDGECOLUMN = 2749,
        SCI_SEARCHANCHOR = 2366,
        /// <summary>
        /// SCI_SEARCHNEXT(int searchFlags, const char *text) -&gt; position<br/>
        /// </summary>
        SCI_SEARCHNEXT = 2367,
        /// <summary>
        /// SCI_SEARCHPREV(int searchFlags, const char *text) -&gt; position<br/>
        /// These messages provide relocatable search support. This allows multiple incremental interactive searches to be
        /// macro recorded while still setting the selection to found text so the find/select operation is self-contained.
        /// These three messages send SCN_MACRORECORD notifications if macro recording is enabled.
        /// </summary>
        SCI_SEARCHPREV = 2368,
        /// <summary>
        /// SCI_LINESONSCREEN -&gt; line<br/>
        /// This returns the number of complete lines visible on the screen. With a constant line height, this is the vertical
        /// space available divided by the line separation. Unless you arrange to size your window to an integral number of
        /// lines, there may be a partial line visible at the bottom of the view.
        /// </summary>
        SCI_LINESONSCREEN = 2370,
        SC_POPUP_NEVER = 0,
        SC_POPUP_ALL = 1,
        SC_POPUP_TEXT = 2,
        /// <summary>
        /// SCI_USEPOPUP(int popUpMode)<br/>
        /// Clicking the wrong button on the mouse pops up a short default editing menu. This may be turned off with
        /// SCI_USEPOPUP(SC_POPUP_NEVER). If you turn it off, context menu commands (in Windows, WM_CONTEXTMENU) will not
        /// be handled by Scintilla, so the parent of the Scintilla window will have the opportunity to handle the message.
        /// </summary>
        SCI_USEPOPUP = 2371,
        /// <summary>
        /// SCI_SELECTIONISRECTANGLE -&gt; bool<br/>
        /// This returns 1 if the current selection is in rectangle mode, 0 if not.
        /// </summary>
        SCI_SELECTIONISRECTANGLE = 2372,
        /// <summary>
        /// SCI_SETZOOM(int zoomInPoints)<br/>
        /// </summary>
        SCI_SETZOOM = 2373,
        /// <summary>
        /// SCI_GETZOOM -&gt; int<br/>
        /// These messages let you set and get the zoom factor directly. There is no limit set on the factors you can set, so
        /// limiting yourself to -10 to +60 to match the incremental zoom functions is a good idea.
        /// </summary>
        SCI_GETZOOM = 2374,
        SC_DOCUMENTOPTION_DEFAULT = 0,
        SC_DOCUMENTOPTION_STYLES_NONE = 0x1,
        SC_DOCUMENTOPTION_TEXT_LARGE = 0x100,
        /// <summary>
        /// SCI_CREATEDOCUMENT(position bytes, int documentOptions) -&gt; pointer<br/>
        /// This message creates a new, empty document and returns a pointer to it. This document is not selected into the
        /// editor and starts with a reference count of 1. This means that you have ownership of it and must either reduce its
        /// reference count by 1 after using SCI_SETDOCPOINTER so that the Scintilla window owns it or you must make sure that
        /// you reduce the reference count by 1 with SCI_RELEASEDOCUMENT before you close the application to avoid memory
        /// leaks. The bytes argument determines the initial memory allocation for the document as it is more efficient
        /// to allocate once rather than rely on the buffer growing as data is added. If SCI_CREATEDOCUMENT fails then 0
        /// is returned.
        /// </summary>
        SCI_CREATEDOCUMENT = 2375,
        /// <summary>
        /// SCI_ADDREFDOCUMENT(&lt;unused&gt;, pointer doc)<br/>
        /// This increases the reference count of a document by 1. If you want to replace the current document in the Scintilla
        /// window and take ownership of the current document, for example if you are editing many documents in one window, do
        /// the following: 1. Use SCI_GETDOCPOINTER to get a pointer to the document, doc. 2. Use
        /// SCI_ADDREFDOCUMENT(0, doc) to increment the reference count. 3. Use SCI_SETDOCPOINTER(0, docNew) to set a
        /// different document or SCI_SETDOCPOINTER(0, 0) to set a new, empty document.
        /// </summary>
        SCI_ADDREFDOCUMENT = 2376,
        /// <summary>
        /// SCI_RELEASEDOCUMENT(&lt;unused&gt;, pointer doc)<br/>
        /// This message reduces the reference count of the document identified by doc. doc must be the result of
        /// SCI_GETDOCPOINTER or SCI_CREATEDOCUMENT and must point at a document that still exists. If you call this on a
        /// document with a reference count of 1 that is still attached to a Scintilla window, bad things will happen. To keep
        /// the world spinning in its orbit you must balance each call to SCI_CREATEDOCUMENT or SCI_ADDREFDOCUMENT
        /// with a call to SCI_RELEASEDOCUMENT .
        /// </summary>
        SCI_RELEASEDOCUMENT = 2377,
        /// <summary>
        /// SCI_GETDOCUMENTOPTIONS -&gt; int<br/>
        /// Returns the options that were used to create the document.
        /// </summary>
        SCI_GETDOCUMENTOPTIONS = 2379,
        /// <summary>
        /// SCI_GETMODEVENTMASK -&gt; int<br/>
        /// These messages set and get an event mask that determines which document change events are notified to the container
        /// with SCN_MODIFIED and SCEN_CHANGE. For example, a container may decide to see only notifications about
        /// changes to text and not styling changes by calling SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT) .
        /// </summary>
        SCI_GETMODEVENTMASK = 2378,
        /// <summary>
        /// SCI_SETCOMMANDEVENTS(bool commandEvents)<br/>
        /// </summary>
        SCI_SETCOMMANDEVENTS = 2717,
        /// <summary>
        /// SCI_GETCOMMANDEVENTS -&gt; bool<br/>
        /// These messages set and get whether SCEN_* command events are sent to the container. For SCEN_CHANGE this
        /// acts as an additional filter over SCI_SETMODEVENTMASK. Most applications should set this off to avoid
        /// overhead and only use SCN_MODIFIED .
        /// </summary>
        SCI_GETCOMMANDEVENTS = 2718,
        /// <summary>
        /// SCI_SETFOCUS(bool focus)<br/>
        /// </summary>
        SCI_SETFOCUS = 2380,
        /// <summary>
        /// SCI_GETFOCUS -&gt; bool<br/>
        /// Scintilla can be told to grab the focus with SCI_GRABFOCUS. This is needed more on GTK where focus handling is
        /// more complicated than on Windows.
        /// </summary>
        SCI_GETFOCUS = 2381,
        SC_STATUS_OK = 0,
        SC_STATUS_FAILURE = 1,
        SC_STATUS_BADALLOC = 2,
        SC_STATUS_WARN_START = 1000,
        SC_STATUS_WARN_REGEX = 1001,
        /// <summary>
        /// SCI_SETSTATUS(int status)<br/>
        /// </summary>
        SCI_SETSTATUS = 2382,
        /// <summary>
        /// SCI_GETSTATUS -&gt; int<br/>
        /// If an error occurs, Scintilla may set an internal error number that can be retrieved with SCI_GETSTATUS. To
        /// clear the error status call SCI_SETSTATUS(0). Status values from 1 to 999 are errors and status
        /// SC_STATUS_WARN_START (1000) and above are warnings. The currently defined statuses are:
        /// </summary>
        SCI_GETSTATUS = 2383,
        /// <summary>
        /// SCI_SETMOUSEDOWNCAPTURES(bool captures)<br/>
        /// </summary>
        SCI_SETMOUSEDOWNCAPTURES = 2384,
        /// <summary>
        /// SCI_GETMOUSEDOWNCAPTURES -&gt; bool<br/>
        /// When the mouse is pressed inside Scintilla, it is captured so future mouse movement events are sent to Scintilla.
        /// This behaviour may be turned off with SCI_SETMOUSEDOWNCAPTURES(0) .
        /// </summary>
        SCI_GETMOUSEDOWNCAPTURES = 2385,
        /// <summary>
        /// SCI_SETMOUSEWHEELCAPTURES(bool captures)<br/>
        /// </summary>
        SCI_SETMOUSEWHEELCAPTURES = 2696,
        /// <summary>
        /// SCI_GETMOUSEWHEELCAPTURES -&gt; bool<br/>
        /// On Windows, Scintilla captures all WM_MOUSEWHEEL messages if it has the focus, even if the mouse pointer is
        /// nowhere near the Scintilla editor window. This behaviour can be changed with SCI_SETMOUSEWHEELCAPTURES(0) so
        /// that Scintilla passes the WM_MOUSEWHEEL messages to its parent window. Scintilla will still react to the
        /// mouse wheel if the mouse pointer is over the editor window.
        /// </summary>
        SCI_GETMOUSEWHEELCAPTURES = 2697,
        /// <summary>
        /// SCI_SETCURSOR(int cursorType)<br/>
        /// </summary>
        SCI_SETCURSOR = 2386,
        /// <summary>
        /// SCI_GETCURSOR -&gt; int<br/>
        /// The cursor is normally chosen in a context sensitive way, so it will be different over the margin than when over
        /// the text. When performing a slow action, you may wish to change to a wait cursor. You set the cursor type with
        /// SCI_SETCURSOR. The cursorType argument can be:
        /// </summary>
        SCI_GETCURSOR = 2387,
        /// <summary>
        /// SCI_SETCONTROLCHARSYMBOL(int symbol)<br/>
        /// </summary>
        SCI_SETCONTROLCHARSYMBOL = 2388,
        /// <summary>
        /// SCI_GETCONTROLCHARSYMBOL -&gt; int<br/>
        /// The mnemonics may be replaced by a nominated symbol with an ASCII code in the range 32 to 255. If you set a symbol
        /// value less than 32, all control characters are displayed as mnemonics. The symbol you set is rendered in the font
        /// of the style set for the character. You can read back the current symbol with the SCI_GETCONTROLCHARSYMBOL
        /// message. The default symbol value is 0.
        /// </summary>
        SCI_GETCONTROLCHARSYMBOL = 2389,
        SCI_WORDPARTLEFT = 2390,
        SCI_WORDPARTLEFTEXTEND = 2391,
        SCI_WORDPARTRIGHT = 2392,
        SCI_WORDPARTRIGHTEXTEND = 2393,
        VISIBLE_SLOP = 0x01,
        VISIBLE_STRICT = 0x04,
        /// <summary>
        /// SCI_SETVISIBLEPOLICY(int visiblePolicy, int visibleSlop)<br/>
        /// This determines how the vertical positioning is determined when SCI_ENSUREVISIBLEENFORCEPOLICY is called. It
        /// takes VISIBLE_SLOP and VISIBLE_STRICT flags for the visiblePolicy parameter. It is similar in operation
        /// to SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop) .
        /// </summary>
        SCI_SETVISIBLEPOLICY = 2394,
        SCI_DELLINELEFT = 2395,
        SCI_DELLINERIGHT = 2396,
        /// <summary>
        /// SCI_SETXOFFSET(int xOffset)<br/>
        /// </summary>
        SCI_SETXOFFSET = 2397,
        /// <summary>
        /// SCI_GETXOFFSET -&gt; int<br/>
        /// The xOffset is the horizontal scroll position in pixels of the start of the text view. A value of 0 is the
        /// normal position with the first text column visible at the left of the view.
        /// </summary>
        SCI_GETXOFFSET = 2398,
        SCI_CHOOSECARETX = 2399,
        SCI_GRABFOCUS = 2400,
        CARET_SLOP = 0x01,
        CARET_STRICT = 0x04,
        CARET_JUMPS = 0x10,
        CARET_EVEN = 0x08,
        /// <summary>
        /// SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)<br/>
        /// </summary>
        SCI_SETXCARETPOLICY = 2402,
        /// <summary>
        /// SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)<br/>
        /// These set the caret policy. The value of caretPolicy is a combination of CARET_SLOP, CARET_STRICT ,
        /// CARET_JUMPS and CARET_EVEN .
        /// </summary>
        SCI_SETYCARETPOLICY = 2403,
        /// <summary>
        /// SCI_SETPRINTWRAPMODE(int wrapMode)<br/>
        /// </summary>
        SCI_SETPRINTWRAPMODE = 2406,
        /// <summary>
        /// SCI_GETPRINTWRAPMODE -&gt; int<br/>
        /// These two functions get and set the printer wrap mode. wrapMode can be set to SC_WRAP_NONE (0) or
        /// SC_WRAP_WORD (1). The default is SC_WRAP_WORD, which wraps printed output so that all characters fit
        /// into the print rectangle. If you set SC_WRAP_NONE, each line of text generates one line of output and the line
        /// is truncated if it is too long to fit into the print area. SC_WRAP_WORD tries to wrap only between words as
        /// indicated by white space or style changes although if a word is longer than a line, it will be wrapped before
        /// the line end. SC_WRAP_CHAR is not supported for printing.
        /// </summary>
        SCI_GETPRINTWRAPMODE = 2407,
        /// <summary>
        /// SCI_SETHOTSPOTACTIVEFORE(bool useSetting, colour fore)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETHOTSPOTACTIVEFORE = 2410,
        /// <summary>
        /// SCI_GETHOTSPOTACTIVEFORE -&gt; colour<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETHOTSPOTACTIVEFORE = 2494,
        /// <summary>
        /// SCI_SETHOTSPOTACTIVEBACK(bool useSetting, colour back)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETHOTSPOTACTIVEBACK = 2411,
        /// <summary>
        /// SCI_GETHOTSPOTACTIVEBACK -&gt; colour<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETHOTSPOTACTIVEBACK = 2495,
        /// <summary>
        /// SCI_SETHOTSPOTACTIVEUNDERLINE(bool underline)<br/>
        /// </summary>
        SCI_SETHOTSPOTACTIVEUNDERLINE = 2412,
        /// <summary>
        /// SCI_GETHOTSPOTACTIVEUNDERLINE -&gt; bool<br/>
        /// </summary>
        SCI_GETHOTSPOTACTIVEUNDERLINE = 2496,
        /// <summary>
        /// SCI_SETHOTSPOTSINGLELINE(bool singleLine)<br/>
        /// </summary>
        SCI_SETHOTSPOTSINGLELINE = 2421,
        /// <summary>
        /// SCI_GETHOTSPOTSINGLELINE -&gt; bool<br/>
        /// While the cursor hovers over text in a style with the hotspot attribute set, the default colouring can be modified
        /// and an underline drawn with these settings. Single line mode stops a hotspot from wrapping onto next line.
        /// </summary>
        SCI_GETHOTSPOTSINGLELINE = 2497,
        SCI_PARADOWN = 2413,
        SCI_PARADOWNEXTEND = 2414,
        SCI_PARAUP = 2415,
        SCI_PARAUPEXTEND = 2416,
        /// <summary>
        /// SCI_POSITIONBEFORE(position pos) -&gt; position<br/>
        /// </summary>
        SCI_POSITIONBEFORE = 2417,
        /// <summary>
        /// SCI_POSITIONAFTER(position pos) -&gt; position<br/>
        /// These messages return the position before and after another position in the document taking into account the
        /// current code page. The minimum position returned is 0 and the maximum is the last position in the document.
        /// If called with a position within a multi byte character will return the position of the start/end of that
        /// character.
        /// </summary>
        SCI_POSITIONAFTER = 2418,
        /// <summary>
        /// SCI_POSITIONRELATIVE(position pos, position relative) -&gt; position<br/>
        /// Count a number of whole characters before or after the argument position and return that position. The minimum
        /// position returned is 0 and the maximum is the last position in the document. If the position goes past the
        /// document end then 0 is returned.
        /// </summary>
        SCI_POSITIONRELATIVE = 2670,
        /// <summary>
        /// SCI_POSITIONRELATIVECODEUNITS(position pos, position relative) -&gt; position<br/>
        /// </summary>
        SCI_POSITIONRELATIVECODEUNITS = 2716,
        /// <summary>
        /// SCI_COPYRANGE(position start, position end)<br/>
        /// </summary>
        SCI_COPYRANGE = 2419,
        /// <summary>
        /// SCI_COPYTEXT(position length, const char *text)<br/>
        /// SCI_COPYRANGE copies a range of text from the document to the system clipboard and SCI_COPYTEXT copies a
        /// supplied piece of text to the system clipboard.
        /// </summary>
        SCI_COPYTEXT = 2420,
        SC_SEL_STREAM = 0,
        SC_SEL_RECTANGLE = 1,
        SC_SEL_LINES = 2,
        SC_SEL_THIN = 3,
        /// <summary>
        /// SCI_SETSELECTIONMODE(int selectionMode)<br/>
        /// </summary>
        SCI_SETSELECTIONMODE = 2422,
        /// <summary>
        /// SCI_CHANGESELECTIONMODE(int selectionMode)<br/>
        /// </summary>
        SCI_CHANGESELECTIONMODE = 2659,
        /// <summary>
        /// SCI_GETSELECTIONMODE -&gt; int<br/>
        /// The functions set, change, and get the selection mode, which can be stream( SC_SEL_STREAM =0) or
        /// rectangular( SC_SEL_RECTANGLE =1) or by lines( SC_SEL_LINES =2) or thin rectangular( SC_SEL_THIN
        /// =3). When SCI_SETSELECTIONMODE sets these modes, regular caret moves will extend or reduce the selection,
        /// until the mode is cancelled by a call with same value, or with SCI_CANCEL, or with SCI_SETMOVEEXTENDSSELECTION .
        /// SCI_CHANGESELECTIONMODE sets the mode but does not make regular caret moves extend or reduce the selection.
        /// </summary>
        SCI_GETSELECTIONMODE = 2423,
        /// <summary>
        /// SCI_SETMOVEEXTENDSSELECTION(bool moveExtendsSelection)<br/>
        /// </summary>
        SCI_SETMOVEEXTENDSSELECTION = 2719,
        /// <summary>
        /// SCI_GETMOVEEXTENDSSELECTION -&gt; bool<br/>
        /// This controls whether regular caret moves extends the selection leaving the anchor unchanged. It is 1 if regular
        /// caret moves will extend or reduce the selection, 0 if not. SCI_SETSELECTIONMODE toggles this setting between on and
        /// off.
        /// </summary>
        SCI_GETMOVEEXTENDSSELECTION = 2706,
        /// <summary>
        /// SCI_GETLINESELSTARTPOSITION(line line) -&gt; position<br/>
        /// </summary>
        SCI_GETLINESELSTARTPOSITION = 2424,
        /// <summary>
        /// SCI_GETLINESELENDPOSITION(line line) -&gt; position<br/>
        /// Retrieve the position of the start and end of the selection at the given line with INVALID_POSITION returned if no
        /// selection on this line.
        /// </summary>
        SCI_GETLINESELENDPOSITION = 2425,
        SCI_LINEDOWNRECTEXTEND = 2426,
        SCI_LINEUPRECTEXTEND = 2427,
        SCI_CHARLEFTRECTEXTEND = 2428,
        SCI_CHARRIGHTRECTEXTEND = 2429,
        SCI_HOMERECTEXTEND = 2430,
        SCI_VCHOMERECTEXTEND = 2431,
        SCI_LINEENDRECTEXTEND = 2432,
        SCI_PAGEUPRECTEXTEND = 2433,
        SCI_PAGEDOWNRECTEXTEND = 2434,
        SCI_STUTTEREDPAGEUP = 2435,
        SCI_STUTTEREDPAGEUPEXTEND = 2436,
        SCI_STUTTEREDPAGEDOWN = 2437,
        SCI_STUTTEREDPAGEDOWNEXTEND = 2438,
        SCI_WORDLEFTEND = 2439,
        SCI_WORDLEFTENDEXTEND = 2440,
        SCI_WORDRIGHTEND = 2441,
        SCI_WORDRIGHTENDEXTEND = 2442,
        /// <summary>
        /// SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char *characters)<br/>
        /// </summary>
        SCI_SETWHITESPACECHARS = 2443,
        /// <summary>
        /// SCI_GETWHITESPACECHARS(&lt;unused&gt;, char *characters) -&gt; int<br/>
        /// Similar to SCI_SETWORDCHARS, this message allows the user to define which chars Scintilla considers as
        /// whitespace. Setting the whitespace chars allows the user to fine-tune Scintilla's behaviour doing such
        /// things as moving the cursor to the start or end of a word; for example, by defining punctuation chars as
        /// whitespace, they will be skipped over when the user presses ctrl+left or ctrl+right. This function should be
        /// called after SCI_SETWORDCHARS as it will reset the whitespace characters to the default set.
        /// SCI_GETWHITESPACECHARS behaves similarly to SCI_GETWORDCHARS .
        /// </summary>
        SCI_GETWHITESPACECHARS = 2647,
        /// <summary>
        /// SCI_SETPUNCTUATIONCHARS(&lt;unused&gt;, const char *characters)<br/>
        /// </summary>
        SCI_SETPUNCTUATIONCHARS = 2648,
        /// <summary>
        /// SCI_GETPUNCTUATIONCHARS(&lt;unused&gt;, char *characters) -&gt; int<br/>
        /// Similar to SCI_SETWORDCHARS and SCI_SETWHITESPACECHARS, this message allows the user to define which chars
        /// Scintilla considers as punctuation. SCI_GETPUNCTUATIONCHARS behaves similarly to SCI_GETWORDCHARS .
        /// </summary>
        SCI_GETPUNCTUATIONCHARS = 2649,
        SCI_SETCHARSDEFAULT = 2444,
        /// <summary>
        /// SCI_AUTOCGETCURRENT -&gt; int<br/>
        /// This message selects an item in the autocompletion list. It searches the list of words for the first that matches
        /// select. By default, comparisons are case sensitive, but you can change this with SCI_AUTOCSETIGNORECASE. The
        /// match is character by character for the length of the select string. That is, if select is "Fred" it will
        /// match "Frederick" if this is the first item in the list that begins with "Fred". If an item is found, it is
        /// selected. If the item is not found, the autocompletion list closes if auto-hide is true (see SCI_AUTOCSETAUTOHIDE
        /// ). The current selection index can be retrieved with SCI_AUTOCGETCURRENT .
        /// </summary>
        SCI_AUTOCGETCURRENT = 2445,
        /// <summary>
        /// SCI_AUTOCGETCURRENTTEXT(&lt;unused&gt;, char *text NUL-terminated) -&gt; int<br/>
        /// This message retrieves the current selected text in the autocompletion list. Normally the SCN_AUTOCSELECTION
        /// notification is used instead.
        /// </summary>
        SCI_AUTOCGETCURRENTTEXT = 2610,
        SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE = 0,
        SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE = 1,
        /// <summary>
        /// SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR(int behaviour)<br/>
        /// </summary>
        SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR = 2634,
        /// <summary>
        /// SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR -&gt; int<br/>
        /// When autocompletion is set to ignore case( SCI_AUTOCSETIGNORECASE ), by default it will nonetheless select the
        /// first list member that matches in a case sensitive way to entered characters. This corresponds to a behaviour
        /// property of SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE (0). If you want autocompletion to ignore case at all,
        /// choose SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE (1).
        /// </summary>
        SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR = 2635,
        SC_MULTIAUTOC_ONCE = 0,
        SC_MULTIAUTOC_EACH = 1,
        /// <summary>
        /// SCI_AUTOCSETMULTI(int multi)<br/>
        /// </summary>
        SCI_AUTOCSETMULTI = 2636,
        /// <summary>
        /// SCI_AUTOCGETMULTI -&gt; int<br/>
        /// When autocompleting with multiple selections present, the autocompleted text can go into just the main selection with
        /// SC_MULTIAUTOC_ONCE (0) or into each selection with SC_MULTIAUTOC_EACH (1). The default is
        /// SC_MULTIAUTOC_ONCE .
        /// </summary>
        SCI_AUTOCGETMULTI = 2637,
        SC_ORDER_PRESORTED = 0,
        SC_ORDER_PERFORMSORT = 1,
        SC_ORDER_CUSTOM = 2,
        /// <summary>
        /// SCI_AUTOCSETORDER(int order)<br/>
        /// </summary>
        SCI_AUTOCSETORDER = 2660,
        /// <summary>
        /// SCI_AUTOCGETORDER -&gt; int<br/>
        /// The default setting SC_ORDER_PRESORTED (0) requires that the list be provided in alphabetical sorted order.
        /// </summary>
        SCI_AUTOCGETORDER = 2661,
        /// <summary>
        /// SCI_ALLOCATE(position bytes)<br/>
        /// Allocate a document buffer large enough to store a given number of bytes. The document will not be made smaller
        /// than its current contents.
        /// </summary>
        SCI_ALLOCATE = 2446,
        /// <summary>
        /// SCI_TARGETASUTF8(&lt;unused&gt;, char *s) -&gt; position<br/>
        /// This method retrieves the value of the target encoded as UTF-8 which is the default encoding of GTK so is useful
        /// for retrieving text for use in other parts of the user interface, such as find and replace dialogs. The length of
        /// the encoded text in bytes is returned. Cocoa uses UTF-16 which is easily converted from UTF-8 so this method can
        /// be used to perform the more complex work of transcoding from the various encodings supported.
        /// </summary>
        SCI_TARGETASUTF8 = 2447,
        /// <summary>
        /// SCI_SETLENGTHFORENCODE(position bytes)<br/>
        /// SCI_ENCODEDFROMUTF8 converts a UTF-8 string into the document's encoding which is useful for taking the results
        /// of a find dialog, for example, and receiving a string of bytes that can be searched for in the document. Since the
        /// text can contain nul bytes, the SCI_SETLENGTHFORENCODE method can be used to set the length that will be
        /// converted. If set to -1, the length is determined by finding a nul byte. The length of the converted string is
        /// returned.
        /// </summary>
        SCI_SETLENGTHFORENCODE = 2448,
        /// <summary>
        /// SCI_ENCODEDFROMUTF8(const char *utf8, char *encoded) -&gt; position<br/>
        /// </summary>
        SCI_ENCODEDFROMUTF8 = 2449,
        /// <summary>
        /// SCI_FINDCOLUMN(line line, position column) -&gt; position<br/>
        /// This message returns the position of a column on a line taking the width of tabs into account. It treats a
        /// multi-byte character as a single column. Column numbers, like lines start at 0.
        /// </summary>
        SCI_FINDCOLUMN = 2456,
        SC_CARETSTICKY_OFF = 0,
        SC_CARETSTICKY_ON = 1,
        SC_CARETSTICKY_WHITESPACE = 2,
        /// <summary>
        /// SCI_GETCARETSTICKY -&gt; int<br/>
        /// </summary>
        SCI_GETCARETSTICKY = 2457,
        /// <summary>
        /// SCI_SETCARETSTICKY(int useCaretStickyBehaviour)<br/>
        /// </summary>
        SCI_SETCARETSTICKY = 2458,
        SCI_TOGGLECARETSTICKY = 2459,
        /// <summary>
        /// SCI_SETPASTECONVERTENDINGS(bool convert)<br/>
        /// </summary>
        SCI_SETPASTECONVERTENDINGS = 2467,
        /// <summary>
        /// SCI_GETPASTECONVERTENDINGS -&gt; bool<br/>
        /// If this property is set then when text is pasted any line ends are converted to match the document's end of line
        /// mode as set with SCI_SETEOLMODE. Defaults to true.
        /// </summary>
        SCI_GETPASTECONVERTENDINGS = 2468,
        /// <summary>
        /// SCI_REPLACERECTANGULAR(position length, const char *text)<br/>
        /// Replaces the selected text or empty selection with the given text. The insertion is performed similarly to
        /// rectangular pastes: new lines in the given text are interpreted as moving to the next line without inserting new
        /// lines unless at the end of the document.
        /// </summary>
        SCI_REPLACERECTANGULAR = 2771,
        SCI_SELECTIONDUPLICATE = 2469,
        /// <summary>
        /// SCI_SETCARETLINEBACKALPHA( alpha alpha)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETCARETLINEBACKALPHA = 2470,
        /// <summary>
        /// SCI_GETCARETLINEBACKALPHA -&gt; int<br/>
        /// These APIs are discouraged. It is better to use the SC_ELEMENT_CARET_LINE_BACK element mentioned in the
        /// previous section. You can choose to make the background colour of the line containing the caret different with
        /// these messages. To do this, set the desired background colour with SCI_SETCARETLINEBACK, then use
        /// SCI_SETCARETLINEVISIBLE(true) to enable the effect. You can cancel the effect with
        /// SCI_SETCARETLINEVISIBLE(false). The two SCI_GETCARET* functions return the state and the colour. This form of
        /// background colouring has highest priority when a line has markers that would otherwise change the background
        /// colour. The caret line may also be drawn translucently which allows other background colours to show
        /// through. This is done by setting the alpha (translucency) value by calling SCI_SETCARETLINEBACKALPHA. When
        /// the alpha is not SC_ALPHA_NOALPHA, the caret line is drawn after all other features so will affect the
        /// colour of all other features.
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETCARETLINEBACKALPHA = 2471,
        CARETSTYLE_INVISIBLE = 0,
        CARETSTYLE_LINE = 1,
        CARETSTYLE_BLOCK = 2,
        CARETSTYLE_OVERSTRIKE_BAR = 0,
        CARETSTYLE_OVERSTRIKE_BLOCK = 0x10,
        CARETSTYLE_CURSES = 0x20,
        CARETSTYLE_INS_MASK = 0xF,
        CARETSTYLE_BLOCK_AFTER = 0x100,
        /// <summary>
        /// SCI_SETCARETSTYLE(int caretStyle)<br/>
        /// </summary>
        SCI_SETCARETSTYLE = 2512,
        /// <summary>
        /// SCI_GETCARETSTYLE -&gt; int<br/>
        /// The style of the caret can be set with SCI_SETCARETSTYLE. There are separate styles for insert mode (lower
        /// 4-bits, CARETSTYLE_INS_MASK ), overtype mode (bit 4), and curses mode (bit 5).
        /// CARETSTYLE_INVISIBLE CARETSTYLE_LINE CARETSTYLE_BLOCK
        /// CARETSTYLE_OVERSTRIKE_BAR CARETSTYLE_OVERSTRIKE_BLOCK
        /// CARETSTYLE_CURSES CARETSTYLE_BLOCK_AFTER CARETSTYLE_BLOCK or
        /// CARETSTYLE_CURSES. The block caret draws most combining and multibyte
        /// character sequences successfully, though some fonts like Thai Fonts (and possibly others) can sometimes appear
        /// strange when the cursor is positioned at these characters, which may result in only drawing a part of the
        /// cursor character sequence. This is most notable on Windows platforms.
        /// </summary>
        SCI_GETCARETSTYLE = 2513,
        /// <summary>
        /// SCI_SETINDICATORCURRENT(int indicator)<br/>
        /// </summary>
        SCI_SETINDICATORCURRENT = 2500,
        /// <summary>
        /// SCI_GETINDICATORCURRENT -&gt; int<br/>
        /// These two messages set and get the indicator that will be affected by calls to SCI_INDICATORFILLRANGE(position start,
        /// position lengthFill) and SCI_INDICATORCLEARRANGE(position start, position lengthClear) .
        /// </summary>
        SCI_GETINDICATORCURRENT = 2501,
        /// <summary>
        /// SCI_SETINDICATORVALUE(int value)<br/>
        /// </summary>
        SCI_SETINDICATORVALUE = 2502,
        /// <summary>
        /// SCI_GETINDICATORVALUE -&gt; int<br/>
        /// These two messages set and get the value that will be set by calls to SCI_INDICATORFILLRANGE .
        /// </summary>
        SCI_GETINDICATORVALUE = 2503,
        /// <summary>
        /// SCI_INDICATORFILLRANGE(position start, position lengthFill)<br/>
        /// </summary>
        SCI_INDICATORFILLRANGE = 2504,
        /// <summary>
        /// SCI_INDICATORCLEARRANGE(position start, position lengthClear)<br/>
        /// These two messages fill or clear a range for the current indicator. SCI_INDICATORFILLRANGE fills with the current
        /// value.
        /// </summary>
        SCI_INDICATORCLEARRANGE = 2505,
        /// <summary>
        /// SCI_INDICATORALLONFOR(position pos) -&gt; int<br/>
        /// Retrieve a bitmap value representing which indicators are non-zero at a position. Only the first 32 indicators are
        /// represented in the result so no IME indicators are included.
        /// </summary>
        SCI_INDICATORALLONFOR = 2506,
        /// <summary>
        /// SCI_INDICATORVALUEAT(int indicator, position pos) -&gt; int<br/>
        /// Retrieve the value of a particular indicator at a position.
        /// </summary>
        SCI_INDICATORVALUEAT = 2507,
        /// <summary>
        /// SCI_INDICATORSTART(int indicator, position pos) -&gt; position<br/>
        /// </summary>
        SCI_INDICATORSTART = 2508,
        /// <summary>
        /// SCI_INDICATOREND(int indicator, position pos) -&gt; position<br/>
        /// Find the start or end of a range with one value from a position within the range. Can be used to iterate through
        /// the document to discover all the indicator positions.
        /// </summary>
        SCI_INDICATOREND = 2509,
        /// <summary>
        /// SCI_SETPOSITIONCACHE(int size)<br/>
        /// </summary>
        SCI_SETPOSITIONCACHE = 2514,
        /// <summary>
        /// SCI_GETPOSITIONCACHE -&gt; int<br/>
        /// The position cache stores position information for short runs of text so that their layout can be determined more
        /// quickly if the run recurs. The size in entries of this cache can be set with SCI_SETPOSITIONCACHE .
        /// </summary>
        SCI_GETPOSITIONCACHE = 2515,
        /// <summary>
        /// SCI_SETLAYOUTTHREADS(int threads)<br/>
        /// </summary>
        SCI_SETLAYOUTTHREADS = 2775,
        /// <summary>
        /// SCI_GETLAYOUTTHREADS -&gt; int<br/>
        /// The time taken to measure text runs on wide lines or when wrapping can be improved by performing the task
        /// concurrently on multiple threads when SCI_SUPPORTSFEATURE(SC_SUPPORTS_THREAD_SAFE_MEASURE_WIDTHS) is available.
        /// This can be a dramatic improvement- a 4 core processor is often able to reduce text layout time to just over one
        /// quarter of the single-threaded time.
        /// </summary>
        SCI_GETLAYOUTTHREADS = 2776,
        SCI_COPYALLOWLINE = 2519,
        SCI_CUTALLOWLINE = 2810,
        /// <summary>
        /// SCI_SETCOPYSEPARATOR(&lt;unused&gt;, const char *separator)<br/>
        /// </summary>
        SCI_SETCOPYSEPARATOR = 2811,
        /// <summary>
        /// SCI_GETCOPYSEPARATOR(&lt;unused&gt;, char *separator) -&gt; int<br/>
        /// When a multiple selection is copied, this string property is added between each part. Defaults to empty.
        /// </summary>
        SCI_GETCOPYSEPARATOR = 2812,
        /// <summary>
        /// SCI_GETCHARACTERPOINTER -&gt; pointer<br/>
        /// </summary>
        SCI_GETCHARACTERPOINTER = 2520,
        /// <summary>
        /// SCI_GETRANGEPOINTER(position start, position lengthRange) -&gt; pointer<br/>
        /// </summary>
        SCI_GETRANGEPOINTER = 2643,
        /// <summary>
        /// SCI_GETGAPPOSITION -&gt; position<br/>
        /// Grant temporary direct read-only access to the memory used by Scintilla to store the document.
        /// </summary>
        SCI_GETGAPPOSITION = 2644,
        /// <summary>
        /// SCI_INDICSETALPHA(int indicator, alpha alpha)<br/>
        /// </summary>
        SCI_INDICSETALPHA = 2523,
        /// <summary>
        /// SCI_INDICGETALPHA(int indicator) -&gt; int<br/>
        /// These two messages set and get the alpha transparency used for drawing the fill colour of the INDIC_ROUNDBOX and
        /// INDIC_STRAIGHTBOX rectangle. The alpha value can range from 0 (completely transparent) to 255 (no transparency).
        /// </summary>
        SCI_INDICGETALPHA = 2524,
        /// <summary>
        /// SCI_INDICSETOUTLINEALPHA(int indicator, alpha alpha)<br/>
        /// </summary>
        SCI_INDICSETOUTLINEALPHA = 2558,
        /// <summary>
        /// SCI_INDICGETOUTLINEALPHA(int indicator) -&gt; int<br/>
        /// These two messages set and get the alpha transparency used for drawing the outline colour of the INDIC_ROUNDBOX
        /// and INDIC_STRAIGHTBOX rectangle. The alpha value can range from 0 (completely transparent) to 255 (no
        /// transparency).
        /// </summary>
        SCI_INDICGETOUTLINEALPHA = 2559,
        /// <summary>
        /// SCI_SETEXTRAASCENT(int extraAscent)<br/>
        /// </summary>
        SCI_SETEXTRAASCENT = 2525,
        /// <summary>
        /// SCI_GETEXTRAASCENT -&gt; int<br/>
        /// </summary>
        SCI_GETEXTRAASCENT = 2526,
        /// <summary>
        /// SCI_SETEXTRADESCENT(int extraDescent)<br/>
        /// </summary>
        SCI_SETEXTRADESCENT = 2527,
        /// <summary>
        /// SCI_GETEXTRADESCENT -&gt; int<br/>
        /// Text is drawn with the base of each character on a 'baseline'. The height of a line is found from the maximum that
        /// any style extends above the baseline (its 'ascent'), added to the maximum that any style extends below the
        /// baseline (its 'descent'). Space may be added to the maximum ascent( SCI_SETEXTRAASCENT) and the maximum
        /// descent( SCI_SETEXTRADESCENT) to allow for more space between lines. This may done to make the text easier to
        /// read or to accommodate underlines or highlights.
        /// </summary>
        SCI_GETEXTRADESCENT = 2528,
        /// <summary>
        /// SCI_MARKERSYMBOLDEFINED(int markerNumber) -&gt; int<br/>
        /// Returns the symbol defined for a markerNumber with SCI_MARKERDEFINE or SC_MARK_PIXMAP if defined with
        /// SCI_MARKERDEFINEPIXMAP or SC_MARK_RGBAIMAGE if defined with SCI_MARKERDEFINERGBAIMAGE .
        /// </summary>
        SCI_MARKERSYMBOLDEFINED = 2529,
        /// <summary>
        /// SCI_MARGINSETTEXT(line line, const char *text)<br/>
        /// </summary>
        SCI_MARGINSETTEXT = 2530,
        /// <summary>
        /// SCI_MARGINGETTEXT(line line, char *text) -&gt; int<br/>
        /// </summary>
        SCI_MARGINGETTEXT = 2531,
        /// <summary>
        /// SCI_MARGINSETSTYLE(line line, int style)<br/>
        /// </summary>
        SCI_MARGINSETSTYLE = 2532,
        /// <summary>
        /// SCI_MARGINGETSTYLE(line line) -&gt; int<br/>
        /// </summary>
        SCI_MARGINGETSTYLE = 2533,
        /// <summary>
        /// SCI_MARGINSETSTYLES(line line, const char *styles)<br/>
        /// </summary>
        SCI_MARGINSETSTYLES = 2534,
        /// <summary>
        /// SCI_MARGINGETSTYLES(line line, char *styles) -&gt; int<br/>
        /// </summary>
        SCI_MARGINGETSTYLES = 2535,
        SCI_MARGINTEXTCLEARALL = 2536,
        /// <summary>
        /// SCI_MARGINSETSTYLEOFFSET(int style)<br/>
        /// </summary>
        SCI_MARGINSETSTYLEOFFSET = 2537,
        /// <summary>
        /// SCI_MARGINGETSTYLEOFFSET -&gt; int<br/>
        /// Margin styles may be completely separated from standard text styles by setting a style offset. For example,
        /// SCI_MARGINSETSTYLEOFFSET(256) would allow the margin styles to be numbered from 256 up to 511 so they do not
        /// overlap styles set by lexers. Each style number set with SCI_MARGINSETSTYLE or SCI_MARGINSETSTYLES has the
        /// offset added before looking up the style.
        /// </summary>
        SCI_MARGINGETSTYLEOFFSET = 2538,
        SC_MARGINOPTION_NONE = 0,
        SC_MARGINOPTION_SUBLINESELECT = 1,
        /// <summary>
        /// SCI_SETMARGINOPTIONS(int marginOptions)<br/>
        /// </summary>
        SCI_SETMARGINOPTIONS = 2539,
        /// <summary>
        /// SCI_GETMARGINOPTIONS -&gt; int<br/>
        /// Define margin options by enabling appropriate bit flags. At the moment, only one flag is available
        /// SC_MARGINOPTION_SUBLINESELECT =1, which controls how wrapped lines are selected when clicking on margin in front
        /// of them. If SC_MARGINOPTION_SUBLINESELECT is set only sub line of wrapped line is selected, otherwise whole
        /// wrapped line is selected. Margin options are set to SC_MARGINOPTION_NONE =0 by default.
        /// </summary>
        SCI_GETMARGINOPTIONS = 2557,
        /// <summary>
        /// SCI_ANNOTATIONSETTEXT(line line, const char *text)<br/>
        /// </summary>
        SCI_ANNOTATIONSETTEXT = 2540,
        /// <summary>
        /// SCI_ANNOTATIONGETTEXT(line line, char *text) -&gt; int<br/>
        /// </summary>
        SCI_ANNOTATIONGETTEXT = 2541,
        /// <summary>
        /// SCI_ANNOTATIONSETSTYLE(line line, int style)<br/>
        /// </summary>
        SCI_ANNOTATIONSETSTYLE = 2542,
        /// <summary>
        /// SCI_ANNOTATIONGETSTYLE(line line) -&gt; int<br/>
        /// </summary>
        SCI_ANNOTATIONGETSTYLE = 2543,
        /// <summary>
        /// SCI_ANNOTATIONSETSTYLES(line line, const char *styles)<br/>
        /// </summary>
        SCI_ANNOTATIONSETSTYLES = 2544,
        /// <summary>
        /// SCI_ANNOTATIONGETSTYLES(line line, char *styles) -&gt; int<br/>
        /// </summary>
        SCI_ANNOTATIONGETSTYLES = 2545,
        /// <summary>
        /// SCI_ANNOTATIONGETLINES(line line) -&gt; int<br/>
        /// </summary>
        SCI_ANNOTATIONGETLINES = 2546,
        SCI_ANNOTATIONCLEARALL = 2547,
        ANNOTATION_HIDDEN = 0,
        ANNOTATION_STANDARD = 1,
        ANNOTATION_BOXED = 2,
        ANNOTATION_INDENTED = 3,
        /// <summary>
        /// SCI_ANNOTATIONSETVISIBLE(int visible)<br/>
        /// </summary>
        SCI_ANNOTATIONSETVISIBLE = 2548,
        /// <summary>
        /// SCI_ANNOTATIONGETVISIBLE -&gt; int<br/>
        /// Annotations can be made visible in a view and there is a choice of display style when visible. The two messages
        /// set and get the annotation display mode. The visible argument can be one of:
        /// </summary>
        SCI_ANNOTATIONGETVISIBLE = 2549,
        /// <summary>
        /// SCI_ANNOTATIONSETSTYLEOFFSET(int style)<br/>
        /// </summary>
        SCI_ANNOTATIONSETSTYLEOFFSET = 2550,
        /// <summary>
        /// SCI_ANNOTATIONGETSTYLEOFFSET -&gt; int<br/>
        /// Annotation styles may be completely separated from standard text styles by setting a style offset. For example,
        /// SCI_ANNOTATIONSETSTYLEOFFSET(512) would allow the annotation styles to be numbered from 512 up to 767 so they do
        /// not overlap styles set by lexers (or margins if margins offset is 256). Each style number set with
        /// SCI_ANNOTATIONSETSTYLE or SCI_ANNOTATIONSETSTYLES has the offset added before looking up the style.
        /// </summary>
        SCI_ANNOTATIONGETSTYLEOFFSET = 2551,
        SCI_RELEASEALLEXTENDEDSTYLES = 2552,
        /// <summary>
        /// SCI_ALLOCATEEXTENDEDSTYLES(int numberStyles) -&gt; int<br/>
        /// Extended styles are used for features like textual margins and annotations and autocompletion lists as well as
        /// internally by Scintilla. They are outside the range 0..255 used for the styles bytes associated with document
        /// bytes. These functions manage the use of extended styles to ensures that components cooperate in defining styles.
        /// SCI_RELEASEALLEXTENDEDSTYLES releases any extended styles allocated by the container.
        /// SCI_ALLOCATEEXTENDEDSTYLES allocates a range of style numbers after the byte style values and returns the number
        /// of the first allocated style. Ranges for margin, annotation, and autocompletion list styles should be allocated
        /// before calling SCI_MARGINSETSTYLEOFFSET or SCI_ANNOTATIONSETSTYLEOFFSET or SCI_AUTOCSETSTYLE .
        /// </summary>
        SCI_ALLOCATEEXTENDEDSTYLES = 2553,
        UNDO_NONE = 0,
        UNDO_MAY_COALESCE = 1,
        /// <summary>
        /// SCI_ADDUNDOACTION(int token, int flags)<br/>
        /// The container can add its own actions into the undo stack by calling SCI_ADDUNDOACTION and an SCN_MODIFIED
        /// notification will be sent to the container with the SC_MOD_CONTAINER flag when it is time to undo (
        /// SC_PERFORMED_UNDO) or redo( SC_PERFORMED_REDO) the action. The token argument supplied is returned in
        /// the token field of the notification.
        /// </summary>
        SCI_ADDUNDOACTION = 2560,
        /// <summary>
        /// SCI_CHARPOSITIONFROMPOINT(int x, int y) -&gt; position<br/>
        /// </summary>
        SCI_CHARPOSITIONFROMPOINT = 2561,
        /// <summary>
        /// SCI_CHARPOSITIONFROMPOINTCLOSE(int x, int y) -&gt; position<br/>
        /// SCI_CHARPOSITIONFROMPOINT finds the closest character to a point and SCI_CHARPOSITIONFROMPOINTCLOSE is
        /// similar but returns -1 if the point is outside the window or not close to any characters. This is similar to the
        /// previous methods but finds characters rather than inter-character positions.
        /// </summary>
        SCI_CHARPOSITIONFROMPOINTCLOSE = 2562,
        /// <summary>
        /// SCI_SETMOUSESELECTIONRECTANGULARSWITCH(bool mouseSelectionRectangularSwitch)<br/>
        /// </summary>
        SCI_SETMOUSESELECTIONRECTANGULARSWITCH = 2668,
        /// <summary>
        /// SCI_GETMOUSESELECTIONRECTANGULARSWITCH -&gt; bool<br/>
        /// Enable or disable the ability to switch to rectangular selection mode while making a selection with the mouse.
        /// When this option is turned on, mouse selections in stream mode can be switched to rectangular mode by pressing the
        /// corresponding modifier key. They then stick to rectangular mode even when the modifier key is released again. When
        /// this option is turned off, mouse selections will always stick to the mode the selection was started in. It is off
        /// by default.
        /// </summary>
        SCI_GETMOUSESELECTIONRECTANGULARSWITCH = 2669,
        /// <summary>
        /// SCI_SETMULTIPLESELECTION(bool multipleSelection)<br/>
        /// </summary>
        SCI_SETMULTIPLESELECTION = 2563,
        /// <summary>
        /// SCI_GETMULTIPLESELECTION -&gt; bool<br/>
        /// Enable or disable multiple selection. When multiple selection is disabled, it is not possible to select multiple
        /// ranges by holding down the Ctrl key while dragging with the mouse.
        /// </summary>
        SCI_GETMULTIPLESELECTION = 2564,
        /// <summary>
        /// SCI_SETADDITIONALSELECTIONTYPING(bool additionalSelectionTyping)<br/>
        /// </summary>
        SCI_SETADDITIONALSELECTIONTYPING = 2565,
        /// <summary>
        /// SCI_GETADDITIONALSELECTIONTYPING -&gt; bool<br/>
        /// Whether typing, new line, cursor left/right/up/down, backspace, delete, home, and end work with multiple
        /// selections simultaneously. Also allows selection and word and line deletion commands.
        /// </summary>
        SCI_GETADDITIONALSELECTIONTYPING = 2566,
        /// <summary>
        /// SCI_SETADDITIONALCARETSBLINK(bool additionalCaretsBlink)<br/>
        /// </summary>
        SCI_SETADDITIONALCARETSBLINK = 2567,
        /// <summary>
        /// SCI_GETADDITIONALCARETSBLINK -&gt; bool<br/>
        /// Modify the appearance of additional carets so that they can be differentiated from the main caret which has its
        /// appearance set with SC_ELEMENT_CARET, SCI_SETCARETFORE, SCI_GETCARETFORE ,
        /// SCI_SETCARETPERIOD, and SCI_GETCARETPERIOD .
        /// </summary>
        SCI_GETADDITIONALCARETSBLINK = 2568,
        /// <summary>
        /// SCI_SETADDITIONALCARETSVISIBLE(bool additionalCaretsVisible)<br/>
        /// </summary>
        SCI_SETADDITIONALCARETSVISIBLE = 2608,
        /// <summary>
        /// SCI_GETADDITIONALCARETSVISIBLE -&gt; bool<br/>
        /// Determine whether to show additional carets (defaults to true ).
        /// </summary>
        SCI_GETADDITIONALCARETSVISIBLE = 2609,
        /// <summary>
        /// SCI_GETSELECTIONS -&gt; int<br/>
        /// Return the number of selections currently active. There is always at least one selection.
        /// </summary>
        SCI_GETSELECTIONS = 2570,
        /// <summary>
        /// SCI_GETSELECTIONEMPTY -&gt; bool<br/>
        /// Return 1 if every selected range is empty else 0.
        /// </summary>
        SCI_GETSELECTIONEMPTY = 2650,
        SCI_CLEARSELECTIONS = 2571,
        /// <summary>
        /// SCI_SETSELECTION(position caret, position anchor)<br/>
        /// Set a single selection from anchor to caret as the only selection.
        /// </summary>
        SCI_SETSELECTION = 2572,
        /// <summary>
        /// SCI_ADDSELECTION(position caret, position anchor)<br/>
        /// Add a new selection from anchor to caret as the main selection retaining all other selections as additional
        /// selections. Since there is always at least one selection, to set a list of selections, the first selection should
        /// be added with SCI_SETSELECTION and later selections added with SCI_ADDSELECTION
        /// </summary>
        SCI_ADDSELECTION = 2573,
        /// <summary>
        /// SCI_SELECTIONFROMPOINT(int x, int y) -&gt; int<br/>
        /// Return the index of the selection at the point. If there is no selection at the point, return -1. This can be used
        /// to drop a selection or make it the main selection.
        /// </summary>
        SCI_SELECTIONFROMPOINT = 2474,
        /// <summary>
        /// SCI_DROPSELECTIONN(int selection)<br/>
        /// If there are multiple selections, remove the indicated selection. If this was the main selection then make the
        /// previous selection the main and if it was the first then the last selection becomes main. If there is only one
        /// selection, or there is no selection selection, then there is no effect.
        /// </summary>
        SCI_DROPSELECTIONN = 2671,
        /// <summary>
        /// SCI_SETMAINSELECTION(int selection)<br/>
        /// </summary>
        SCI_SETMAINSELECTION = 2574,
        /// <summary>
        /// SCI_GETMAINSELECTION -&gt; int<br/>
        /// One of the selections is the main selection which is used to determine what range of text is automatically visible.
        /// The main selection may be displayed in different colours or with a differently styled caret. Only an already
        /// existing selection can be made main.
        /// </summary>
        SCI_GETMAINSELECTION = 2575,
        /// <summary>
        /// SCI_SETSELECTIONNCARET(int selection, position caret)<br/>
        /// </summary>
        SCI_SETSELECTIONNCARET = 2576,
        /// <summary>
        /// SCI_GETSELECTIONNCARET(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNCARET = 2577,
        /// <summary>
        /// SCI_SETSELECTIONNANCHOR(int selection, position anchor)<br/>
        /// </summary>
        SCI_SETSELECTIONNANCHOR = 2578,
        /// <summary>
        /// SCI_GETSELECTIONNANCHOR(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNANCHOR = 2579,
        /// <summary>
        /// SCI_SETSELECTIONNCARETVIRTUALSPACE(int selection, position space)<br/>
        /// </summary>
        SCI_SETSELECTIONNCARETVIRTUALSPACE = 2580,
        /// <summary>
        /// SCI_GETSELECTIONNCARETVIRTUALSPACE(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNCARETVIRTUALSPACE = 2581,
        /// <summary>
        /// SCI_SETSELECTIONNANCHORVIRTUALSPACE(int selection, position space)<br/>
        /// </summary>
        SCI_SETSELECTIONNANCHORVIRTUALSPACE = 2582,
        /// <summary>
        /// SCI_GETSELECTIONNANCHORVIRTUALSPACE(int selection) -&gt; position<br/>
        /// Set or query the position and amount of virtual space for the caret and anchor of each already existing selection.
        /// </summary>
        SCI_GETSELECTIONNANCHORVIRTUALSPACE = 2583,
        /// <summary>
        /// SCI_SETSELECTIONNSTART(int selection, position anchor)<br/>
        /// </summary>
        SCI_SETSELECTIONNSTART = 2584,
        /// <summary>
        /// SCI_GETSELECTIONNSTART(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNSTART = 2585,
        /// <summary>
        /// SCI_GETSELECTIONNSTARTVIRTUALSPACE(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNSTARTVIRTUALSPACE = 2726,
        /// <summary>
        /// SCI_SETSELECTIONNEND(int selection, position caret)<br/>
        /// </summary>
        SCI_SETSELECTIONNEND = 2586,
        /// <summary>
        /// SCI_GETSELECTIONNENDVIRTUALSPACE(int selection) -&gt; position<br/>
        /// Set or query the start and end position of each already existing selection. Query the virtual space at start and
        /// end of each selection. Mostly of use to query each range for its text. The selection parameter is zero-based.
        /// </summary>
        SCI_GETSELECTIONNENDVIRTUALSPACE = 2727,
        /// <summary>
        /// SCI_GETSELECTIONNEND(int selection) -&gt; position<br/>
        /// </summary>
        SCI_GETSELECTIONNEND = 2587,
        /// <summary>
        /// SCI_SETRECTANGULARSELECTIONCARET(position caret)<br/>
        /// </summary>
        SCI_SETRECTANGULARSELECTIONCARET = 2588,
        /// <summary>
        /// SCI_GETRECTANGULARSELECTIONCARET -&gt; position<br/>
        /// </summary>
        SCI_GETRECTANGULARSELECTIONCARET = 2589,
        /// <summary>
        /// SCI_SETRECTANGULARSELECTIONANCHOR(position anchor)<br/>
        /// </summary>
        SCI_SETRECTANGULARSELECTIONANCHOR = 2590,
        /// <summary>
        /// SCI_GETRECTANGULARSELECTIONANCHOR -&gt; position<br/>
        /// </summary>
        SCI_GETRECTANGULARSELECTIONANCHOR = 2591,
        /// <summary>
        /// SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE(position space)<br/>
        /// </summary>
        SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE = 2592,
        /// <summary>
        /// SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE -&gt; position<br/>
        /// </summary>
        SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE = 2593,
        /// <summary>
        /// SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE(position space)<br/>
        /// </summary>
        SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE = 2594,
        /// <summary>
        /// SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE -&gt; position<br/>
        /// Set or query the position and amount of virtual space for the caret and anchor of the rectangular selection. After
        /// setting the rectangular selection, this is broken down into multiple selections, one for each line.
        /// </summary>
        SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE = 2595,
        SCVS_NONE = 0,
        SCVS_RECTANGULARSELECTION = 1,
        SCVS_USERACCESSIBLE = 2,
        SCVS_NOWRAPLINESTART = 4,
        /// <summary>
        /// SCI_SETVIRTUALSPACEOPTIONS(int virtualSpaceOptions)<br/>
        /// </summary>
        SCI_SETVIRTUALSPACEOPTIONS = 2596,
        /// <summary>
        /// SCI_GETVIRTUALSPACEOPTIONS -&gt; int<br/>
        /// Virtual space can be enabled or disabled for rectangular selections or in other circumstances or in both. There
        /// are three bit flags SCVS_RECTANGULARSELECTION =1, SCVS_USERACCESSIBLE =2, and SCVS_NOWRAPLINESTART
        /// =4 which can be set independently. SCVS_NONE =0, the default, disables all use of virtual space.
        /// </summary>
        SCI_GETVIRTUALSPACEOPTIONS = 2597,
        /// <summary>
        /// SCI_SETRECTANGULARSELECTIONMODIFIER(int modifier)<br/>
        /// </summary>
        SCI_SETRECTANGULARSELECTIONMODIFIER = 2598,
        /// <summary>
        /// SCI_GETRECTANGULARSELECTIONMODIFIER -&gt; int<br/>
        /// On GTK and Qt, the key used to indicate that a rectangular selection should be created when combined with a mouse drag
        /// can be set. The three possible values are SCMOD_CTRL =2, SCMOD_ALT =4 (default) or SCMOD_SUPER =8.
        /// Since SCMOD_ALT may already be used by a window manager, the window manager may need configuring to allow this
        /// choice. SCMOD_SUPER is often a system dependent modifier key such as the Left Windows key on a Windows
        /// keyboard or the Command key on a Mac.
        /// </summary>
        SCI_GETRECTANGULARSELECTIONMODIFIER = 2599,
        /// <summary>
        /// SCI_SETADDITIONALSELFORE( colour fore)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETADDITIONALSELFORE = 2600,
        /// <summary>
        /// SCI_SETADDITIONALSELBACK( colour back)<br/>
        /// Modify the appearance of additional selections so that they can be differentiated from the main selection which has its
        /// appearance set with SC_ELEMENT_SELECTION_TEXT, SC_ELEMENT_SELECTION_BACK, SCI_SETSELALPHA ,
        /// SCI_GETSELALPHA, SCI_SETSELFORE, and SCI_SETSELBACK. The element APIs are preferred and the
        /// following messages discouraged. The additional selection background is drawn on the layer defined for all
        /// selection backgrounds by SCI_SETSELECTIONLAYER. SCI_SETADDITIONALSELFORE and
        /// SCI_SETADDITIONALSELBACK calls have no effect until SCI_SETSELFORE and SCI_SETSELBACK are
        /// called with useSetting value set to true. Subsequent calls to SCI_SETSELFORE, and SCI_SETSELBACK
        /// will overwrite the values set by SCI_SETADDITIONALSEL* functions.
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETADDITIONALSELBACK = 2601,
        /// <summary>
        /// SCI_SETADDITIONALSELALPHA( alpha alpha)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETADDITIONALSELALPHA = 2602,
        /// <summary>
        /// SCI_GETADDITIONALSELALPHA -&gt; int<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETADDITIONALSELALPHA = 2603,
        /// <summary>
        /// SCI_SETADDITIONALCARETFORE( colour fore)<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_SETADDITIONALCARETFORE = 2604,
        /// <summary>
        /// SCI_GETADDITIONALCARETFORE -&gt; colour<br/>
        /// </summary>
        [Obsolete("Use the element colours APIs instead: https://www.scintilla.org/ScintillaDoc.html#ElementColours")]
        SCI_GETADDITIONALCARETFORE = 2605,
        SCI_ROTATESELECTION = 2606,
        SCI_SWAPMAINANCHORCARET = 2607,
        SCI_MULTIPLESELECTADDNEXT = 2688,
        SCI_MULTIPLESELECTADDEACH = 2689,
        /// <summary>
        /// SCI_CHANGELEXERSTATE(position start, position end) -&gt; int<br/>
        /// Indicate that the internal state of a lexer has changed over a range and therefore there may be a need to redraw.
        /// </summary>
        SCI_CHANGELEXERSTATE = 2617,
        /// <summary>
        /// SCI_CONTRACTEDFOLDNEXT(line lineStart) -&gt; line<br/>
        /// Search efficiently for lines that are contracted fold headers. This is useful when saving the user's folding when
        /// switching documents or saving folding with a file. The search starts at line number lineStart and continues
        /// forwards to the end of the file. lineStart is returned if it is a contracted fold header otherwise the next
        /// contracted fold header is returned. If there are no more contracted fold headers then -1 is returned.
        /// </summary>
        SCI_CONTRACTEDFOLDNEXT = 2618,
        SCI_VERTICALCENTRECARET = 2619,
        SCI_MOVESELECTEDLINESUP = 2620,
        SCI_MOVESELECTEDLINESDOWN = 2621,
        /// <summary>
        /// SCI_SETIDENTIFIER(int identifier)<br/>
        /// </summary>
        SCI_SETIDENTIFIER = 2622,
        /// <summary>
        /// SCI_GETIDENTIFIER -&gt; int<br/>
        /// These two messages set and get the identifier of the Scintilla instance which is included in notifications as the
        /// idFrom field. When an application creates multiple Scintilla widgets, this allows the source of each
        /// notification to be found. On Windows, this value is initialised in the CreateWindow call and stored as the
        /// GWLP_ID attribute of the window. The value should be small, preferably less than 16 bits, rather than a
        /// pointer as some of the functions will only transmit 16 or 32 bits.
        /// </summary>
        SCI_GETIDENTIFIER = 2623,
        /// <summary>
        /// SCI_RGBAIMAGESETWIDTH(int width)<br/>
        /// </summary>
        SCI_RGBAIMAGESETWIDTH = 2624,
        /// <summary>
        /// SCI_RGBAIMAGESETHEIGHT(int height)<br/>
        /// </summary>
        SCI_RGBAIMAGESETHEIGHT = 2625,
        /// <summary>
        /// SCI_RGBAIMAGESETSCALE(int scalePercent)<br/>
        /// </summary>
        SCI_RGBAIMAGESETSCALE = 2651,
        /// <summary>
        /// SCI_MARKERDEFINERGBAIMAGE(int markerNumber, const char *pixels)<br/>
        /// Markers can be set to translucent pixmaps with this message. The RGBA format is used for the pixmap. The width
        /// and height must previously been set with the SCI_RGBAIMAGESETWIDTH and SCI_RGBAIMAGESETHEIGHT messages.
        /// </summary>
        SCI_MARKERDEFINERGBAIMAGE = 2626,
        /// <summary>
        /// SCI_REGISTERRGBAIMAGE(int type, const char *pixels)<br/>
        /// </summary>
        SCI_REGISTERRGBAIMAGE = 2627,
        SCI_SCROLLTOSTART = 2628,
        SCI_SCROLLTOEND = 2629,
        SC_TECHNOLOGY_DEFAULT = 0,
        SC_TECHNOLOGY_DIRECTWRITE = 1,
        SC_TECHNOLOGY_DIRECTWRITERETAIN = 2,
        SC_TECHNOLOGY_DIRECTWRITEDC = 3,
        /// <summary>
        /// SCI_SETTECHNOLOGY(int technology)<br/>
        /// </summary>
        SCI_SETTECHNOLOGY = 2630,
        /// <summary>
        /// SCI_GETTECHNOLOGY -&gt; int<br/>
        /// The technology property allows choosing between different drawing APIs and options. On most platforms, the only
        /// choice is SC_TECHNOLOGY_DEFAULT (0). On Windows Vista or later, SC_TECHNOLOGY_DIRECTWRITE (1),
        /// SC_TECHNOLOGY_DIRECTWRITERETAIN (2), or SC_TECHNOLOGY_DIRECTWRITEDC (3) can be chosen to use the
        /// Direct2D and DirectWrite APIs for higher quality antialiased drawing. SC_TECHNOLOGY_DIRECTWRITERETAIN differs
        /// from SC_TECHNOLOGY_DIRECTWRITE by requesting that the frame is retained after being presented which may
        /// prevent drawing failures on some cards and drivers. SC_TECHNOLOGY_DIRECTWRITEDC differs from
        /// SC_TECHNOLOGY_DIRECTWRITE by using DirectWrite to draw into a GDI DC.
        /// </summary>
        SCI_GETTECHNOLOGY = 2631,
        /// <summary>
        /// SCI_CREATELOADER(position bytes, int documentOptions) -&gt; pointer<br/>
        /// Create an object that supports the ILoader interface which can be used to load data and then be turned into a
        /// Scintilla document object for attachment to a view object. The bytes argument determines the initial memory
        /// allocation for the document as it is more efficient to allocate once rather than rely on the buffer growing as
        /// data is added. If SCI_CREATELOADER fails then 0 is returned.
        /// </summary>
        SCI_CREATELOADER = 2632,
        /// <summary>
        /// SCI_FINDINDICATORSHOW(position start, position end)<br/>
        /// </summary>
        SCI_FINDINDICATORSHOW = 2640,
        /// <summary>
        /// SCI_FINDINDICATORFLASH(position start, position end)<br/>
        /// These two messages show and animate the find indicator. The indicator remains visible with SCI_FINDINDICATORSHOW and
        /// fades out after showing for half a second with SCI_FINDINDICATORFLASH. SCI_FINDINDICATORSHOW behaves
        /// similarly to the macOS TextEdit and Safari applications and is best suited to editing documentation where the
        /// search target is often a word. SCI_FINDINDICATORFLASH is similar to Xcode and is suited to editing source code
        /// where the match will often be located next to operators which would otherwise be hidden under the indicator's
        /// padding.
        /// </summary>
        SCI_FINDINDICATORFLASH = 2641,
        SCI_FINDINDICATORHIDE = 2642,
        SCI_VCHOMEDISPLAY = 2652,
        SCI_VCHOMEDISPLAYEXTEND = 2653,
        /// <summary>
        /// SCI_GETCARETLINEVISIBLEALWAYS -&gt; bool<br/>
        /// Choose to make the caret line always visible even when the window is not in focus. Default behaviour
        /// SCI_SETCARETLINEVISIBLEALWAYS(false) the caret line is only visible when the window is in focus.
        /// </summary>
        SCI_GETCARETLINEVISIBLEALWAYS = 2654,
        /// <summary>
        /// SCI_SETCARETLINEVISIBLEALWAYS(bool alwaysVisible)<br/>
        /// </summary>
        SCI_SETCARETLINEVISIBLEALWAYS = 2655,
        SC_LINE_END_TYPE_DEFAULT = 0,
        SC_LINE_END_TYPE_UNICODE = 1,
        /// <summary>
        /// SCI_SETLINEENDTYPESALLOWED(int lineEndBitSet)<br/>
        /// </summary>
        SCI_SETLINEENDTYPESALLOWED = 2656,
        /// <summary>
        /// SCI_GETLINEENDTYPESALLOWED -&gt; int<br/>
        /// By default, only the ASCII line ends are interpreted. Unicode line ends may be requested with
        /// SCI_SETLINEENDTYPESALLOWED(SC_LINE_END_TYPE_UNICODE) but this will be ineffective unless the lexer also allows
        /// you Unicode line ends. SCI_GETLINEENDTYPESALLOWED returns the current state.
        /// </summary>
        SCI_GETLINEENDTYPESALLOWED = 2657,
        /// <summary>
        /// SCI_GETLINEENDTYPESACTIVE -&gt; int<br/>
        /// SCI_GETLINEENDTYPESACTIVE reports the set of line ends currently interpreted by Scintilla. It is
        /// SCI_GETLINEENDTYPESSUPPORTED &amp; SCI_GETLINEENDTYPESALLOWED .
        /// </summary>
        SCI_GETLINEENDTYPESACTIVE = 2658,
        /// <summary>
        /// SCI_SETREPRESENTATION(const char *encodedCharacter, const char *representation)<br/>
        /// </summary>
        SCI_SETREPRESENTATION = 2665,
        /// <summary>
        /// SCI_GETREPRESENTATION(const char *encodedCharacter, char *representation NUL-terminated) -&gt; int<br/>
        /// </summary>
        SCI_GETREPRESENTATION = 2666,
        /// <summary>
        /// SCI_CLEARREPRESENTATION(const char *encodedCharacter)<br/>
        /// Any character, including those normally displayed as mnemonics may be represented by a Unicode string inverted in
        /// a rounded rectangle.
        /// </summary>
        SCI_CLEARREPRESENTATION = 2667,
        SCI_CLEARALLREPRESENTATIONS = 2770,
        SC_REPRESENTATION_PLAIN = 0,
        SC_REPRESENTATION_BLOB = 1,
        SC_REPRESENTATION_COLOUR = 0x10,
        /// <summary>
        /// SCI_SETREPRESENTATIONAPPEARANCE(const char *encodedCharacter, int appearance)<br/>
        /// </summary>
        SCI_SETREPRESENTATIONAPPEARANCE = 2766,
        /// <summary>
        /// SCI_GETREPRESENTATIONAPPEARANCE(const char *encodedCharacter) -&gt; int<br/>
        /// The appearance may be changed using these flags. If a colour is set and the appearance is set without
        /// SC_REPRESENTATION_COLOUR then the representation will show in the colour of the underlying text.
        /// </summary>
        SCI_GETREPRESENTATIONAPPEARANCE = 2767,
        /// <summary>
        /// SCI_SETREPRESENTATIONCOLOUR(const char *encodedCharacter, colouralpha colour)<br/>
        /// </summary>
        SCI_SETREPRESENTATIONCOLOUR = 2768,
        /// <summary>
        /// SCI_GETREPRESENTATIONCOLOUR(const char *encodedCharacter) -&gt; colouralpha<br/>
        /// The colour and translucency of a representation may be set.
        /// </summary>
        SCI_GETREPRESENTATIONCOLOUR = 2769,
        /// <summary>
        /// SCI_EOLANNOTATIONSETTEXT(line line, const char *text)<br/>
        /// </summary>
        SCI_EOLANNOTATIONSETTEXT = 2740,
        /// <summary>
        /// SCI_EOLANNOTATIONGETTEXT(line line, char *text) -&gt; int<br/>
        /// </summary>
        SCI_EOLANNOTATIONGETTEXT = 2741,
        /// <summary>
        /// SCI_EOLANNOTATIONSETSTYLE(line line, int style)<br/>
        /// </summary>
        SCI_EOLANNOTATIONSETSTYLE = 2742,
        /// <summary>
        /// SCI_EOLANNOTATIONGETSTYLE(line line) -&gt; int<br/>
        /// </summary>
        SCI_EOLANNOTATIONGETSTYLE = 2743,
        SCI_EOLANNOTATIONCLEARALL = 2744,
        EOLANNOTATION_HIDDEN = 0x0,
        EOLANNOTATION_STANDARD = 0x1,
        EOLANNOTATION_BOXED = 0x2,
        EOLANNOTATION_STADIUM = 0x100,
        EOLANNOTATION_FLAT_CIRCLE = 0x101,
        EOLANNOTATION_ANGLE_CIRCLE = 0x102,
        EOLANNOTATION_CIRCLE_FLAT = 0x110,
        EOLANNOTATION_FLATS = 0x111,
        EOLANNOTATION_ANGLE_FLAT = 0x112,
        EOLANNOTATION_CIRCLE_ANGLE = 0x120,
        EOLANNOTATION_FLAT_ANGLE = 0x121,
        EOLANNOTATION_ANGLES = 0x122,
        /// <summary>
        /// SCI_EOLANNOTATIONSETVISIBLE(int visible)<br/>
        /// </summary>
        SCI_EOLANNOTATIONSETVISIBLE = 2745,
        /// <summary>
        /// SCI_EOLANNOTATIONGETVISIBLE -&gt; int<br/>
        /// End of Line Annotations can be made visible in a view and there is a choice of display style when visible. The two
        /// messages set and get the annotation display mode. The visible argument can be one of:
        /// </summary>
        SCI_EOLANNOTATIONGETVISIBLE = 2746,
        /// <summary>
        /// SCI_EOLANNOTATIONSETSTYLEOFFSET(int style)<br/>
        /// </summary>
        SCI_EOLANNOTATIONSETSTYLEOFFSET = 2747,
        /// <summary>
        /// SCI_EOLANNOTATIONGETSTYLEOFFSET -&gt; int<br/>
        /// End of Line Annotation styles may be completely separated from standard text styles by setting a style offset. For
        /// example, SCI_EOLANNOTATIONSETSTYLEOFFSET(512) would allow the end of line annotation styles to be numbered from
        /// 512 up to 767 so they do not overlap styles set by lexers (or margins if margins offset is 256). Each style number
        /// set with SCI_EOLANNOTATIONSETSTYLE has the offset added before looking up the style.
        /// </summary>
        SCI_EOLANNOTATIONGETSTYLEOFFSET = 2748,
        SC_SUPPORTS_LINE_DRAWS_FINAL = 0,
        SC_SUPPORTS_PIXEL_DIVISIONS = 1,
        SC_SUPPORTS_FRACTIONAL_STROKE_WIDTH = 2,
        SC_SUPPORTS_TRANSLUCENT_STROKE = 3,
        SC_SUPPORTS_PIXEL_MODIFICATION = 4,
        SC_SUPPORTS_THREAD_SAFE_MEASURE_WIDTHS = 5,
        /// <summary>
        /// SCI_SUPPORTSFEATURE(int feature) -&gt; bool<br/>
        /// Different platforms support different features and SCI_SUPPORTSFEATURE can be used to check which are currently
        /// available. For example, on Win32, Direct2D supports drawing translucent lines but GDI does not so
        /// SCI_SUPPORTSFEATURE(SC_SUPPORTS_TRANSLUCENT_STROKE) will return 1 for Direct2D and 0 for GDI. Its possible that
        /// translucent line drawing will be implemented in a future revision to the GDI platform layer or will be implemented
        /// on particular Windows versions. This call allows applications to tailor their settings: perhaps displaying a box
        /// with translucent coloured fill on Direct2D but a hollow box on GDI.
        /// </summary>
        SCI_SUPPORTSFEATURE = 2750,
        SC_LINECHARACTERINDEX_NONE = 0,
        SC_LINECHARACTERINDEX_UTF32 = 1,
        SC_LINECHARACTERINDEX_UTF16 = 2,
        /// <summary>
        /// SCI_GETLINECHARACTERINDEX -&gt; int<br/>
        /// Returns which if any indexes are active. It may be SC_LINECHARACTERINDEX_NONE (0) or one or more of
        /// SC_LINECHARACTERINDEX_UTF32 (1) if whole characters are indexed or SC_LINECHARACTERINDEX_UTF16 (2) if UTF-16
        /// code units are indexed. Character indexes are currently only supported for UTF-8 documents.
        /// </summary>
        SCI_GETLINECHARACTERINDEX = 2710,
        /// <summary>
        /// SCI_ALLOCATELINECHARACTERINDEX(int lineCharacterIndex)<br/>
        /// </summary>
        SCI_ALLOCATELINECHARACTERINDEX = 2711,
        /// <summary>
        /// SCI_RELEASELINECHARACTERINDEX(int lineCharacterIndex)<br/>
        /// Allocate or release one or more indexes using same enumeration as SCI_GETLINECHARACTERINDEX. Different aspects
        /// of an application may need indexes for different periods and should allocate for those periods. Indexes use
        /// additional memory so releasing them can help minimize memory but they also take time to recalculate. Scintilla may
        /// also allocate indexes to support features like accessibility or input method editors. Only one index of each type
        /// is created for a document at a time.
        /// </summary>
        SCI_RELEASELINECHARACTERINDEX = 2712,
        /// <summary>
        /// SCI_LINEFROMINDEXPOSITION(position pos, int lineCharacterIndex) -&gt; line<br/>
        /// </summary>
        SCI_LINEFROMINDEXPOSITION = 2713,
        /// <summary>
        /// SCI_INDEXPOSITIONFROMLINE(line line, int lineCharacterIndex) -&gt; position<br/>
        /// The document line of a particular character or code unit may be found by calling SCI_LINEFROMINDEXPOSITION with one
        /// of SC_LINECHARACTERINDEX_UTF32 (1) or SC_LINECHARACTERINDEX_UTF16 (2). The inverse action, finds the
        /// starting position of a document line either in characters or code units from the document start by calling
        /// SCI_INDEXPOSITIONFROMLINE with the same lineCharacterIndex argument.
        /// </summary>
        SCI_INDEXPOSITIONFROMLINE = 2714,
        SCI_STARTRECORD = 3001,
        SCI_STOPRECORD = 3002,
        /// <summary>
        /// SCI_GETLEXER -&gt; int<br/>
        /// You can retrieve an integer lexer ID for the current lexer from the SCLEX_* enumeration in SciLexer.h. Some
        /// lexers may not have a lexer ID, just a lexer name in which case 0 is returned.
        /// </summary>
        SCI_GETLEXER = 4002,
        /// <summary>
        /// SCI_COLOURISE(position start, position end)<br/>
        /// This requests the current lexer or the container (if the lexer is set to NULL) to style the document between start
        /// and end. If end is -1, the document is styled from start to the end. If the "fold" property is
        /// set to "1" and your lexer or container supports folding, fold levels are also set. This message causes a
        /// redraw.
        /// </summary>
        SCI_COLOURISE = 4003,
        /// <summary>
        /// SCI_SETPROPERTY(const char *key, const char *value)<br/>
        /// You can communicate settings to lexers with keyword:value string pairs. There is no limit to the number of keyword
        /// pairs you can set, other than available memory. key is a case sensitive keyword, value is a string that is
        /// associated with the keyword. If there is already a value string associated with the keyword, it is replaced. If you
        /// pass a zero length string, the message does nothing. Both key and value are used without modification;
        /// extra spaces at the beginning or end of key are significant.
        /// </summary>
        SCI_SETPROPERTY = 4004,
        KEYWORDSET_MAX = 30,
        /// <summary>
        /// SCI_SETKEYWORDS(int keyWordSet, const char *keyWords)<br/>
        /// You can set up to 9 lists of keywords for use by the current lexer. keyWordSet can be 0 to 8 (actually 0 to
        /// KEYWORDSET_MAX) and selects which keyword list to replace. keyWords is a list of keywords separated by
        /// spaces, tabs, "\n" or "\r" or any combination of these. It is expected that the keywords will be composed
        /// of standard ASCII printing characters, but there is nothing to stop you using any non-separator character codes
        /// from 1 to 255 (except common sense).
        /// </summary>
        SCI_SETKEYWORDS = 4005,
        /// <summary>
        /// SCI_GETPROPERTY(const char *key, char *value NUL-terminated) -&gt; int<br/>
        /// Lookup a keyword:value pair using the specified key; if found, copy the value to the user-supplied buffer and
        /// return the length (not including the terminating 0). If not found, copy an empty string to the buffer and return
        /// 0.
        /// </summary>
        SCI_GETPROPERTY = 4008,
        /// <summary>
        /// SCI_GETPROPERTYEXPANDED(const char *key, char *value) -&gt; int<br/>
        /// This is now the same as SCI_GETPROPERTY- no expansion is performed.
        /// </summary>
        SCI_GETPROPERTYEXPANDED = 4009,
        /// <summary>
        /// SCI_GETPROPERTYINT(const char *key, int defaultValue) -&gt; int<br/>
        /// Lookup a keyword:value pair using the specified key; if found, interpret the value as an integer and return it. If
        /// not found (or the value is an empty string) then return the supplied default. If the keyword:value pair is found but is
        /// not a number, then return 0.
        /// </summary>
        SCI_GETPROPERTYINT = 4010,
        /// <summary>
        /// SCI_GETLEXERLANGUAGE(&lt;unused&gt;, char *language NUL-terminated) -&gt; int<br/>
        /// SCI_GETLEXERLANGUAGE returns the name of the current lexer which must be set with SCI_SETILEXER. To locate
        /// the name for a lexer, open the relevant lexilla/lexers/Lex*.cxx file and search for LexerModule. The third
        /// argument in the LexerModule constructor is the name to use.
        /// </summary>
        SCI_GETLEXERLANGUAGE = 4012,
        /// <summary>
        /// SCI_PRIVATELEXERCALL(int operation, pointer pointer) -&gt; pointer<br/>
        /// Call into a lexer in a way not understood by Scintilla.
        /// </summary>
        SCI_PRIVATELEXERCALL = 4013,
        /// <summary>
        /// SCI_PROPERTYNAMES(&lt;unused&gt;, char *names NUL-terminated) -&gt; int<br/>
        /// </summary>
        SCI_PROPERTYNAMES = 4014,
        SC_TYPE_BOOLEAN = 0,
        SC_TYPE_INTEGER = 1,
        SC_TYPE_STRING = 2,
        /// <summary>
        /// SCI_PROPERTYTYPE(const char *name) -&gt; int<br/>
        /// </summary>
        SCI_PROPERTYTYPE = 4015,
        /// <summary>
        /// SCI_DESCRIBEPROPERTY(const char *name, char *description NUL-terminated) -&gt; int<br/>
        /// Information may be retrieved about the properties that can be set for the current lexer. This information is only
        /// available for newer lexers. SCI_PROPERTYNAMES returns a string with all of the valid properties separated by "\n".
        /// If the lexer does not support this call then an empty string is returned. Properties may be boolean (
        /// SC_TYPE_BOOLEAN ), integer( SC_TYPE_INTEGER ), or string( SC_TYPE_STRING) and this is found with
        /// SCI_PROPERTYTYPE. A description of a property in English is returned by SCI_DESCRIBEPROPERTY .
        /// </summary>
        SCI_DESCRIBEPROPERTY = 4016,
        /// <summary>
        /// SCI_DESCRIBEKEYWORDSETS(&lt;unused&gt;, char *descriptions NUL-terminated) -&gt; int<br/>
        /// A description of all of the keyword sets separated by "\n" is returned by SCI_DESCRIBEKEYWORDSETS .
        /// </summary>
        SCI_DESCRIBEKEYWORDSETS = 4017,
        /// <summary>
        /// SCI_GETLINEENDTYPESSUPPORTED -&gt; int<br/>
        /// SCI_GETLINEENDTYPESSUPPORTED reports the different types of line ends supported by the current lexer. This is a
        /// bit set although there is currently only a single choice with either SC_LINE_END_TYPE_DEFAULT (0) or
        /// SC_LINE_END_TYPE_UNICODE (1). These values are also used by the other messages concerned with Unicode line ends.
        /// </summary>
        SCI_GETLINEENDTYPESSUPPORTED = 4018,
        /// <summary>
        /// SCI_ALLOCATESUBSTYLES(int styleBase, int numberStyles) -&gt; int<br/>
        /// Allocate some number of substyles for a particular base style returning the first substyle number allocated. A
        /// failure, such as requesting more substyles than available, is indicated by returning a negative number. Lexers
        /// that support substyles will commonly allow allocating 64 substyles. Substyles are allocated contiguously.
        /// </summary>
        SCI_ALLOCATESUBSTYLES = 4020,
        /// <summary>
        /// SCI_GETSUBSTYLESSTART(int styleBase) -&gt; int<br/>
        /// </summary>
        SCI_GETSUBSTYLESSTART = 4021,
        /// <summary>
        /// SCI_GETSUBSTYLESLENGTH(int styleBase) -&gt; int<br/>
        /// Return the start and length of the substyles allocated for a base style.
        /// </summary>
        SCI_GETSUBSTYLESLENGTH = 4022,
        /// <summary>
        /// SCI_GETSTYLEFROMSUBSTYLE(int subStyle) -&gt; int<br/>
        /// For a sub style, return the base style, else return the argument.
        /// </summary>
        SCI_GETSTYLEFROMSUBSTYLE = 4027,
        /// <summary>
        /// SCI_GETPRIMARYSTYLEFROMSTYLE(int style) -&gt; int<br/>
        /// For a secondary style, return the primary style, else return the argument.
        /// </summary>
        SCI_GETPRIMARYSTYLEFROMSTYLE = 4028,
        SCI_FREESUBSTYLES = 4023,
        /// <summary>
        /// SCI_SETIDENTIFIERS(int style, const char *identifiers)<br/>
        /// Similar to SCI_SETKEYWORDS but for substyles. The prefix feature available with SCI_SETKEYWORDS is not
        /// implemented for SCI_SETIDENTIFIERS .
        /// </summary>
        SCI_SETIDENTIFIERS = 4024,
        /// <summary>
        /// SCI_DISTANCETOSECONDARYSTYLES -&gt; int<br/>
        /// Returns the distance between a primary style and its corresponding secondary style.
        /// </summary>
        SCI_DISTANCETOSECONDARYSTYLES = 4025,
        /// <summary>
        /// SCI_GETSUBSTYLEBASES(&lt;unused&gt;, char *styles NUL-terminated) -&gt; int<br/>
        /// Fill styles with a byte for each style that can be split into substyles.
        /// </summary>
        SCI_GETSUBSTYLEBASES = 4026,
        /// <summary>
        /// SCI_GETNAMEDSTYLES -&gt; int<br/>
        /// Retrieve the number of named styles for the lexer.
        /// </summary>
        SCI_GETNAMEDSTYLES = 4029,
        /// <summary>
        /// SCI_NAMEOFSTYLE(int style, char *name) -&gt; int<br/>
        /// Retrieve the name of a style. This is a C preprocessor symbol like "SCE_C_COMMENTDOC".
        /// </summary>
        SCI_NAMEOFSTYLE = 4030,
        /// <summary>
        /// SCI_TAGSOFSTYLE(int style, char *tags) -&gt; int<br/>
        /// Retrieve the tags of a style. This is a space-separated set of words like "comment documentation".
        /// </summary>
        SCI_TAGSOFSTYLE = 4031,
        /// <summary>
        /// SCI_DESCRIPTIONOFSTYLE(int style, char *description) -&gt; int<br/>
        /// Retrieve an English-language description of a style which may be suitable for display in a user interface. This
        /// looks like "Doc comment: block comments beginning with /** or /*!".
        /// </summary>
        SCI_DESCRIPTIONOFSTYLE = 4032,
        /// <summary>
        /// SCI_SETILEXER(&lt;unused&gt;, pointer ilexer)<br/>
        /// SCI_SETILEXER allows setting a lexer as an ILexer5*. The lexer may be implemented by an application or a
        /// shared library such as Lexilla.
        /// </summary>
        SCI_SETILEXER = 4033,
        SC_MOD_NONE = 0x0,
        SC_MOD_INSERTTEXT = 0x1,
        SC_MOD_DELETETEXT = 0x2,
        SC_MOD_CHANGESTYLE = 0x4,
        SC_MOD_CHANGEFOLD = 0x8,
        SC_PERFORMED_USER = 0x10,
        SC_PERFORMED_UNDO = 0x20,
        SC_PERFORMED_REDO = 0x40,
        SC_MULTISTEPUNDOREDO = 0x80,
        SC_LASTSTEPINUNDOREDO = 0x100,
        SC_MOD_CHANGEMARKER = 0x200,
        SC_MOD_BEFOREINSERT = 0x400,
        SC_MOD_BEFOREDELETE = 0x800,
        SC_MULTILINEUNDOREDO = 0x1000,
        SC_STARTACTION = 0x2000,
        SC_MOD_CHANGEINDICATOR = 0x4000,
        /// <summary>
        /// SC_MOD_CHANGELINESTATE SCI_SETLINESTATE was called. line
        /// </summary>
        SC_MOD_CHANGELINESTATE = 0x8000,
        /// <summary>
        /// SC_MOD_CHANGEMARGIN line
        /// </summary>
        SC_MOD_CHANGEMARGIN = 0x10000,
        /// <summary>
        /// SC_MOD_CHANGEANNOTATION line
        /// </summary>
        SC_MOD_CHANGEANNOTATION = 0x20000,
        /// <summary>
        /// SC_MOD_CONTAINER SCI_ADDUNDOACTION . SC_MODEVENTMASKALL SCI_SETMODEVENTMASK . SCEN_CHANGE<br/>
        /// SCEN_CHANGE (768) is fired when the text (not the style) of the document changes. This notification is sent using
        /// the WM_COMMAND message on Windows and the "command" signal on GTK as this is the behaviour of the standard Edit
        /// control( SCEN_CHANGE has the same value as the Windows Edit control EN_CHANGE ). No other information
        /// is sent. If you need more detailed information use SCN_MODIFIED. You can filter the types of changes you
        /// are notified about with SCI_SETMODEVENTMASK and SCI_SETCOMMANDEVENTS .
        /// </summary>
        SC_MOD_CONTAINER = 0x40000,
        /// <summary>
        /// SC_MOD_LEXERSTATE position, length
        /// </summary>
        SC_MOD_LEXERSTATE = 0x80000,
        /// <summary>
        /// SC_MOD_INSERTCHECK SCI_CHANGEINSERTION . No other modifications may be made in this handler. position, length, text SC_MULTILINEUNDOREDO SC_STARTACTION
        /// </summary>
        SC_MOD_INSERTCHECK = 0x100000,
        /// <summary>
        /// SC_MOD_CHANGETABSTOPS SCI_CLEARTABSTOPS or SCI_ADDTABSTOP was called. line
        /// </summary>
        SC_MOD_CHANGETABSTOPS = 0x200000,
        SC_MOD_CHANGEEOLANNOTATION = 0x400000,
        SC_MODEVENTMASKALL = 0x7FFFFF,
        SC_UPDATE_NONE = 0x0,
        SC_UPDATE_CONTENT = 0x1,
        SC_UPDATE_SELECTION = 0x2,
        SC_UPDATE_V_SCROLL = 0x4,
        SC_UPDATE_H_SCROLL = 0x8,
        SCEN_CHANGE = 768,
        SCEN_SETFOCUS = 512,
        SCEN_KILLFOCUS = 256,
        SCK_DOWN = 300,
        SCK_UP = 301,
        SCK_LEFT = 302,
        SCK_RIGHT = 303,
        SCK_HOME = 304,
        SCK_END = 305,
        SCK_PRIOR = 306,
        SCK_NEXT = 307,
        SCK_DELETE = 308,
        SCK_INSERT = 309,
        SCK_ESCAPE = 7,
        SCK_BACK = 8,
        SCK_TAB = 9,
        SCK_RETURN = 13,
        SCK_ADD = 310,
        SCK_SUBTRACT = 311,
        SCK_DIVIDE = 312,
        SCK_WIN = 313,
        SCK_RWIN = 314,
        SCK_MENU = 315,
        SCMOD_NORM = 0,
        SCMOD_SHIFT = 1,
        SCMOD_CTRL = 2,
        SCMOD_ALT = 4,
        SCMOD_SUPER = 8,
        SCMOD_META = 16,
        SC_AC_FILLUP = 1,
        SC_AC_DOUBLECLICK = 2,
        SC_AC_TAB = 3,
        SC_AC_NEWLINE = 4,
        SC_AC_COMMAND = 5,
        SC_AC_SINGLE_CHOICE = 6,
        SC_CHARACTERSOURCE_DIRECT_INPUT = 0,
        SC_CHARACTERSOURCE_TENTATIVE_INPUT = 1,
        SC_CHARACTERSOURCE_IME_RESULT = 2,
        SCN_STYLENEEDED = 2000,
        SCN_CHARADDED = 2001,
        SCN_SAVEPOINTREACHED = 2002,
        SCN_SAVEPOINTLEFT = 2003,
        SCN_MODIFYATTEMPTRO = 2004,
        SCN_KEY = 2005,
        SCN_DOUBLECLICK = 2006,
        SCN_UPDATEUI = 2007,
        SCN_MODIFIED = 2008,
        SCN_MACRORECORD = 2009,
        SCN_MARGINCLICK = 2010,
        SCN_NEEDSHOWN = 2011,
        SCN_PAINTED = 2013,
        SCN_USERLISTSELECTION = 2014,
        SCN_URIDROPPED = 2015,
        SCN_DWELLSTART = 2016,
        SCN_DWELLEND = 2017,
        SCN_ZOOM = 2018,
        SCN_HOTSPOTCLICK = 2019,
        SCN_HOTSPOTDOUBLECLICK = 2020,
        SCN_CALLTIPCLICK = 2021,
        SCN_AUTOCSELECTION = 2022,
        SCN_INDICATORCLICK = 2023,
        SCN_INDICATORRELEASE = 2024,
        SCN_AUTOCCANCELLED = 2025,
        SCN_AUTOCCHARDELETED = 2026,
        SCN_HOTSPOTRELEASECLICK = 2027,
        SCN_FOCUSIN = 2028,
        SCN_FOCUSOUT = 2029,
        SCN_AUTOCCOMPLETED = 2030,
        SCN_MARGINRIGHTCLICK = 2031,
        SCN_AUTOCSELECTIONCHANGE = 2032,
#if !SCI_DISABLE_PROVISIONAL
        SC_BIDIRECTIONAL_DISABLED = 0,
        SC_BIDIRECTIONAL_L2R = 1,
        SC_BIDIRECTIONAL_R2L = 2,
        /// <summary>
        /// SCI_GETBIDIRECTIONAL -&gt; int<br/>
        /// Some languages, like Arabic and Hebrew, are written from right to left instead of from left to right as English is.
        /// Documents that use multiple languages may contain both directions and this is termed "bidirectional". The default
        /// text direction may be right to left or left to right. Scintilla only correctly displays bidirectional text on some
        /// platforms. Currently, there is experimental support for bidirectional text on Win32 using DirectWrite and on macOS
        /// using Cocoa. Only UTF-8 documents will show bidirectional behaviour and only in SC_BIDIRECTIONAL_L2R mode.
        /// Some features, such as virtual space may not work with bidirectional text or may work only in some circumstances.
        /// SC_BIDIRECTIONAL_R2L may be implemented in the future.
        /// </summary>
        SCI_GETBIDIRECTIONAL = 2708,
        /// <summary>
        /// SCI_SETBIDIRECTIONAL(int bidirectional)<br/>
        /// </summary>
        SCI_SETBIDIRECTIONAL = 2709,
#endif
        SC_SEARCHRESULT_LINEBUFFERMAXLENGTH = 2048,
        SCI_GETBOOSTREGEXERRMSG = 5000,
        SCN_FOLDINGSTATECHANGED = 2081,
    }
}
